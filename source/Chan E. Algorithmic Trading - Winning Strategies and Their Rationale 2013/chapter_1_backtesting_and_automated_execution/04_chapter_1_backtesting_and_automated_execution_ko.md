# 백테스팅과 자동 실행 (Backtesting and Automated Execution)

이 책의 초점은 특정 범주의 전략에 있으며 백테스팅(backtesting)의 일반적인 기법에 있지 않지만, 모든 전략에 공통적으로 적용되는 중요한 고려 사항과 흔한 함정들을 먼저 다룰 필요가 있습니다. 이러한 함정을 피하려는 주의 없이 무작정 전략을 백테스트한다면, 그 백테스팅은 쓸모가 없을 것입니다. 더 나쁜 경우에는 오해를 불러일으켜 상당한 재정적 손실을 초래할 수 있습니다.

백테스팅은 일반적으로 전략의 기대 수익률과 기타 통계적 성과 측정치를 계산하는 것을 포함하므로, 이러한 수치의 통계적 유의성(statistical significance)에 대해 의문을 제기하는 것이 합리적입니다. 우리는 가설 검정(hypothesis testing)과 몬테카를로 시뮬레이션(Monte Carlo simulation)의 방법론을 사용하여 통계적 유의성을 추정하는 다양한 방법을 논의할 것입니다. 일반적으로, 백테스트에서 왕복 거래(round trip trades)가 많을수록 통계적 유의성이 높아집니다. 그러나 백테스트가 함정 없이 올바르게 수행되고 높은 통계적 유의성을 가진다 하더라도, 반드시 미래 수익률을 예측할 수 있다는 것을 의미하지는 않습니다. 체제 전환(regime shifts)이 모든 것을 망칠 수 있으며, 몇 가지 중요한 역사적 사례를 강조할 것입니다.

백테스팅을 위한 소프트웨어 플랫폼의 선택 또한 중요한 고려 사항이며 초기에 다루어야 합니다. 좋은 선택은 생산성을 크게 높일 뿐만 아니라, 가장 광범위한 자산 클래스에서 가장 넓은 범위의 전략을 백테스트할 수 있게 해줍니다.

그리고 앞서 언급한 함정을 범할 가능성을 줄이거나 제거할 것입니다. 또한 좋은 백테스팅 플랫폼의 선택이 종종 좋은 자동 실행 플랫폼의 선택과 연결되는 이유를 설명할 것입니다: 종종 최고의 플랫폼은 두 기능을 모두 결합합니다.

## 백테스팅의 중요성 (The Importance of Backtesting)

백테스팅은 과거 데이터를 거래 전략에 입력하여 어떤 성과를 냈을지 확인하는 과정입니다. 그 희망은 과거 성과가 미래 성과에 대해 무엇을 기대할 수 있는지 알려준다는 것입니다. 처음부터 전략을 개발한 경우 이 과정의 중요성은 명백합니다. 왜냐하면 그것이 어떤 성과를 냈는지 확실히 알고 싶을 것이기 때문입니다. 그러나 출판물에서 전략을 읽었고 저자가 명시된 성과에 대해 거짓말을 하지 않았다고 신뢰하더라도, 독립적으로 전략을 백테스트하는 것은 여전히 필수적입니다. 여기에는 몇 가지 이유가 있습니다.

종종 전략의 수익성은 구현의 세부 사항에 민감하게 의존합니다. 예를 들어, 주식 주문을 시장 개장 시 주문(market-on-open orders)으로 보내야 하는지, 아니면 개장 직후 시장가 주문(market orders)으로 보내야 하는지? E-mini S&P 500 선물 주문을 오후 4시 주식 시장 마감 직전에 보내야 하는지, 아니면 오후 4시 15분 선물 시장 마감 직전에 보내야 하는지? 매수호가(bid)나 매도호가(ask)를 사용하여 거래를 시작해야 하는지, 아니면 최종 가격(last price)을 사용해야 하는지? 이 모든 세부 사항은 출판된 논문에서 간과되는 경향이 있으며, 주요 아이디어에서 주의를 분산시키지 않기 위해 종종 정당하게 그러합니다. 그러나 이러한 세부 사항은 실시간 거래 전략의 수익성에 상당한 영향을 미칠 수 있습니다. 이러한 세부 사항을 정확히 확정하여 우리 자신의 자동 실행 시스템에 구현하는 유일한 방법은 전략을 직접 백테스트하는 것입니다. 사실, 이상적으로는 백테스팅 프로그램을 버튼 하나로 자동 실행 프로그램으로 전환할 수 있어야 세부 사항의 정확한 구현을 보장할 수 있습니다.

전략의 모든 세부 사항을 백테스트 프로그램으로 구현한 후, 이를 현미경 아래에 놓고 백테스팅 과정이나 전략 자체의 함정을 찾을 수 있습니다. 예를 들어, 롱(long)과 숏(short) 포지션을 모두 가진 주식 포트폴리오 전략을 백테스트할 때, 일부 주식이 대차가 어렵고(hard to borrow) 합리적인 규모로 쉽게 공매도할 수 없다는 사실을 고려했습니까? 선물에서 시장 간 페어 트레이딩(pair-trading) 전략을 백테스트할 때, 두 시장의 종가가 같은 시간에 발생하는지 확인했습니까? 함정의 전체 목록은 길고 지루하지만, "백테스팅의 일반적인 함정" 섹션에서 몇 가지 일반적인 것들을 강조하겠습니다. 종종 각 시장과 각 전략은 고유한 매우 특정한 함정 세트를 제시합니다. 일반적으로 함정은 전략의 백테스트 성과를 과거 실제 성과에 비해 부풀리는 경향이 있으며, 이는 특히 위험합니다.

전략의 모든 세부 사항을 백테스팅 프로그램에서 이해하고 구현했으며, 발견할 수 있는 함정이 없다고 스스로 만족하더라도, 출판된 전략을 백테스팅하는 것은 여전히 중요한 이점을 제공할 수 있습니다.

출판된 전략을 백테스팅하면 출판 이후 기간에 진정한 표본 외 테스트(out-of-sample testing)를 수행할 수 있습니다. 표본 외 성과가 좋지 않다면, 전략이 제한된 데이터 세트에서만 작동했을 수 있다는 우려를 가져야 합니다. 이것은 실제로 사람들이 인식하는 것보다 더 중요한 포인트입니다. 많은 저자들이 논문에서 백테스트 결과가 "표본 외 데이터로 검증되었다"고 주장할 것입니다. 그러나 실제로 표본 외 테스트 결과가 좋지 않았다면, 저자들은 일부 매개변수를 변경했거나 모델을 상당히 수정하여 "표본 외" 데이터에서도 결과가 좋아 보이도록 했을 수 있습니다. 따라서 진정한 표본 외 테스트는 전략이 출판되어 확정될 때까지 실제로 시작될 수 없습니다.

마지막으로, 전략을 직접 백테스팅함으로써 종종 전략을 개선하고 더 수익성 있게 또는 덜 위험하게 만드는 방법을 찾을 수 있습니다. 거래에서의 백테스팅 과정은 "과학적 방법(scientific method)"을 따라야 합니다. 시장에 대한 우리 자신의 직관이나 일부 출판된 연구에 기반하여 차익거래 기회(arbitrage opportunity)에 대한 가설로 시작해야 합니다. 그런 다음 백테스트를 통해 이 가설을 확인하거나 반박합니다. 백테스트 결과가 충분히 좋지 않으면 가설을 수정하고 과정을 반복할 수 있습니다.

앞서 강조한 바와 같이, 전략의 성과는 종종 세부 사항에 매우 민감하며, 이러한 세부 사항의 작은 변화가 상당한 개선을 가져올 수 있습니다. 이러한 변화는 이동 평균을 결정하기 위한 회고 기간(look-back period)을 변경하거나, 종가 대신 시가에 주문을 입력하는 것만큼 간단할 수 있습니다. 전략을 백테스팅하면 모든 세부 사항을 실험할 수 있습니다.

## 백테스팅의 일반적인 함정 (Common Pitfalls of Backtesting)

거의 모든 전략이 백테스팅에서 오류를 범할 수 있는 고유한 기회를 허용하지만, 일부는 모든 시장에 일반적으로 적용되고 다른 일부는 특정 시장에 관련된 여러 공통 주제가 있습니다.

### 선행 편향 (Look-ahead Bias)

이름이 암시하듯, 선행 편향(look-ahead bias)은 백테스트 프로그램이 오늘의 거래 신호를 결정하기 위해 내일의 가격을 사용하고 있음을 의미합니다. 또는, 더 일반적으로, 현재 시점에서 "예측"을 하기 위해 미래 정보를 사용하는 것입니다. 선행 편향의 일반적인 예는 백테스팅 중에 같은 날의 고가나 저가를 사용하여 당일 진입 신호를 결정하는 것입니다. (거래일이 끝나기 전에는 그날의 고가와 저가가 얼마인지 알 수 없습니다.) 선행 편향은 본질적으로 프로그래밍 오류이며 백테스트 프로그램에만 감염될 수 있고 실시간 거래 프로그램에는 영향을 줄 수 없습니다. 왜냐하면 실시간 거래 프로그램이 미래 정보를 얻을 방법이 없기 때문입니다. 백테스팅과 실시간 거래 프로그램 간의 이 차이는 또한 선행 편향을 피하는 명백한 방법을 가리킵니다. 백테스팅과 실시간 거래 프로그램이 동일하고, 백테스팅과 실시간 거래의 유일한 차이가 프로그램에 어떤 종류의 데이터를 입력하느냐(전자는 과거 데이터, 후자는 실시간 시장 데이터)라면, 프로그램에 선행 편향이 있을 수 없습니다. 이 장의 뒷부분에서 백테스트와 실시간 실행 모두에 동일한 소스 코드를 사용할 수 있는 플랫폼을 살펴볼 것입니다.

### 데이터 스누핑 편향과 선형성의 아름다움 (Data-Snooping Bias and the Beauty of Linearity)

데이터 스누핑 편향(data-snooping bias)은 과거의 무작위적이고 일시적인 시장 패턴에 맞추어 과거 성과를 좋게 보이도록 적합시킨 너무 많은 자유 매개변수(free parameters)에 의해 발생합니다. 이러한 무작위 시장 패턴은 미래에 재발할 가능성이 낮으므로, 이러한 패턴에 적합된 모델은 예측력이 거의 없을 것입니다.

데이터 스누핑 편향을 감지하는 방법은 잘 알려져 있습니다: 표본 외 데이터(out-of-sample data)에서 모델을 테스트하고 표본 외 테스트를 통과하지 못하는 모델을 거부해야 합니다. 그러나 이것은 말하기는 쉽지만 실행하기는 어렵습니다. 수주간의 작업을 포기하고 모델을 완전히 버릴 의향이 정말로 있습니까? 우리 중 소수만이 그러한 결단력을 가지고 있습니다. 우리 대부분은 대신 모델을 이리저리 수정하여 표본 내(in-sample)와 표본 외 결과 모두에서 합리적으로 잘 수행하도록 할 것입니다. 그러나 이렇게 함으로써 우리는 표본 외 데이터를 표본 내 데이터로 전환한 것입니다!

고정된 표본 외 데이터 세트에서의 성과 때문에 모델을 버리기를 원하지 않거나(결국, 이 표본 외 데이터에서의 저조한 성과는 단지 운이 나빴기 때문일 수 있습니다), 처음부터 작은 데이터 세트를 가지고 있어 이 데이터의 대부분을 사용하여 모델을 수정해야 한다면, 교차 검증(cross-validation)의 아이디어를 고려해야 합니다. 즉, 모델을 훈련하고 수정하기 위해 데이터의 여러 다른 부분 집합을 선택하고, 더 중요하게는 모델이 이러한 다른 부분 집합에서 잘 수행되는지 확인해야 합니다. 높은 샤프 비율(Sharpe ratio)과 짧은 최대 손실 기간(maximum drawdown duration)을 가진 모델을 선호하는 한 가지 이유는 이것이 거의 자동으로 모델이 교차 검증 테스트를 통과하도록 보장하기 때문입니다: 모델이 테스트에 실패하는 유일한 부분 집합은 드문 손실 기간입니다.

데이터 스누핑 편향을 최소화할 수 있는 거래 전략 구성에 대한 일반적인 접근 방식이 있습니다: 가능한 한 적은 매개변수로 모델을 가능한 한 단순하게 만드는 것입니다. 많은 트레이더들이 두 번째 원칙을 인정하지만, 매개변수는 적지만 복잡한 거래 규칙이 많은 모델도 데이터 스누핑 편향에 마찬가지로 취약하다는 것을 인식하지 못합니다. 두 원칙 모두 비선형 모델(nonlinear models)이 선형 모델(linear models)보다 데이터 스누핑 편향에 더 취약하다는 결론으로 이어집니다. 왜냐하면 비선형 모델은 더 복잡할 뿐만 아니라 일반적으로 선형 모델보다 더 많은 자유 매개변수를 가지기 때문입니다.

과거 가격 시계열의 단순 외삽으로 가격을 예측하려 한다고 가정해 봅시다. 비선형 모델은 확실히 과거 데이터에 더 잘 적합하겠지만, 그것이 미래 값을 더 잘 예측할 수 있다는 보장은 없습니다. 그러나 비선형 모델과 그 선형 경쟁자의 매개변수 수를 동일하게 고정하더라도, 미적분학에서 익숙한 테일러 급수 전개(Taylor-series expansion)로 비선형 모델을 근사할 수 있다는 것을 기억해야 합니다. 이는 모든 비선형 모델에 대응하는 더 단순한 선형 근사가 보통 존재하며, 이 선형 모델을 사용할 수 없는 이유에 대한 타당한 근거가 제시되어야 함을 의미합니다. (예외는 저차항이 사라지는 특이한 경우입니다. 그러나 그러한 경우는 현실적인 금융 시계열을 거의 설명하지 못합니다.)

수익률에 대해 어떤 확률 분포를 가정해야 하는지의 맥락에서 동등한 추론을 할 수 있습니다. 가우시안 분포(Gaussian distribution)가 금융 시장의 극단적 사건을 포착하지 못한다는 것을 자주 들어왔습니다. 그러나 가우시안 분포를 넘어서는 문제는 대안 분포의 많은 선택에 직면하게 된다는 것입니다. 수익률의 왜도(skew)와 첨도(kurtosis)를 포착할 수 있는 스튜던트 *t*-분포여야 할까요, 아니면 유한한 2차 모멘트를 완전히 없애는 파레토 분포(Pareto distribution)여야 할까요? 어떤 선택이든 어느 정도의 자의성이 있을 것이며, 결정은 유한한 관찰 수에 기반할 것입니다. 따라서 오컴의 면도날(Occam's razor)은 비가우시안 분포를 지지하는 강력한 이론적, 경험적 이유가 없는 한 가우시안 형태를 가정해야 한다고 지시합니다.

선형 모델은 선형 가격 예측 공식뿐만 아니라 선형 자본 배분 공식도 의미합니다. 다음 시간 기간 $dt$에서 가격 변화 $dy$가 평균 가격과 현재 가격의 차이에 비례하는 가격 시계열에 대한 평균 회귀(mean-reverting) 모델을 고려한다고 가정합시다: $dy(t) = (\lambda y(t - 1) + \mu)dt + d\epsilon$, 이른바 "오른스타인-울렌벡(Ornstein-Uhlenbeck)" 공식으로, 2장에서 더 자세히 설명하고 검토합니다. 종종 트레이더는 볼린저 밴드(Bollinger band) 모델을 사용하여 이 평균 회귀 가격 시계열에서 수익을 포착하므로, 가격이 특정 임계값을 초과(또는 미달)할 때마다 매도(또는 매수)합니다. 그러나 선형 모델을 고수해야 한다면, 모든 가격 증분에서 매도(또는 매수)해야 하므로, 총 시장 가치는 평균으로부터의 음의 편차에 대략 비례합니다. 일반적인 트레이더 용어로 이것은 "평균 매수(averaging-in)" 또는 "분할 매수(scaling-in)"라고 할 수 있으며, 3장에서 논의되는 기법입니다.

이 책에서 선형 거래 모델의 여러 예를 찾을 수 있습니다. 이 기법의 단순성은 수익이 전략의 미묘하고 복잡한 영리함에서 나오는 것이 아니라 평범하게 보이는 곳에 숨겨진 시장의 본질적인 비효율성에서 나온다는 점을 설명할 수 있게 합니다. 조급한 독자는 예제 4.2를 미리 볼 수 있는데, 이는 상장지수펀드(ETF)와 그 구성 종목 간의 선형 평균 회귀 전략을 보여주며, 예제 4.3과 4.4는 주식에 대한 두 가지 선형 롱-숏 통계적 차익거래(statistical arbitrage) 전략을 보여줍니다.

선형 예측 모델의 가장 극단적인 형태는 모든 계수의 크기가 같은(반드시 부호가 같을 필요는 없는) 것입니다. 예를 들어, 주식 지수의 내일 수익률이 양수인지 예측하는 데 유용한 여러 요인(*f*)을 식별했다고 가정합시다. 하나의 요인은 오늘의 수익률일 수 있으며, 양의 오늘 수익률이 양의 미래 수익률을 예측합니다. 또 다른 요인은 오늘의 변동성 지수(VIX) 변화일 수 있으며, 음의 변화가 양의 미래 수익률을 예측합니다. 이러한 요인이 여러 개 있을 수 있습니다. 이 요인들을 먼저 Z-점수(Z-scores)로 변환하여 정규화하면(표본 내 데이터 사용!):

$$z(i) = \frac{f(i) - \text{mean}(f)}{\text{std}(f)} \qquad (1.1)$$

여기서 *f*(*i*)는 *i*번째 요인이며, 그런 다음 내일의 수익률 *R*을 다음과 같이 예측할 수 있습니다:

$$R = \text{mean}(R) + \text{std}(R) \frac{\sum_{i=1}^{n} \text{sign}(i)z(i)}{n} \qquad (1.2)$$

*mean*(*f*)과 *std*(*f*)는 다양한 *f*(*i*)의 과거 평균과 표준편차이고, *sign*(*i*)는 *f*(*i*)와 $R$ 사이의 과거 상관관계의 부호이며, *mean*(*R*)과 *std*(*R*)은 각각 1일 수익률의 과거 평균과 표준편차입니다. 노벨 경제학상 수상자 다니엘 카너먼(Daniel Kahneman)은 그의 베스트셀러 *생각에 관한 생각(Thinking, Fast and Slow)*에서 "모든 예측 변수에 동일한 가중치를 할당하는 공식은 표본 추출의 우연에 영향을 받지 않기 때문에 종종 우수하다"(Kahneman, 2011)고 썼습니다. 식 1.2는 주식 수익률 예측에 사용되는 일반적인 요인 모델의 단순화된 버전입니다. *절대* 수익률에 대한 예측은 매우 정확하지 않을 수 있지만, 주식 간의 *상대* 수익률에 대한 예측은 종종 충분히 좋습니다. 이는 주식을 순위 매기는 데 사용하고, 상위 십분위수의 주식을 매수하고 하위 십분위수의 주식을 공매도하여 롱-숏 포트폴리오를 구성하면, 포트폴리오의 평균 수익률이 종종 양수라는 것을 의미합니다.

실제로 목표가 기대 수익률을 도출하는 것이 아니라 주식의 순위를 매기는 것이라면, 식 1.1과 1.2를 사용하지 않고 요인 *f*들을 결합하는 더 간단한 방법이 있습니다. 먼저 요인 *f*(*i*)에 기반하여 주식 *s*의 *순위*(*i*)를 계산할 수 있습니다. 그런 다음 이 순위에 *f*(*i*)와 주식의 기대 수익률 사이의 상관관계 부호를 곱합니다. 마지막으로, 이 부호가 적용된 순위를 모두 합산하여 주식의 순위를 형성합니다:

$$\text{rank}_s = \sum_{i=1}^{n} \text{sign}(i) \text{rank}_s(i) \qquad (1.3)$$

예를 들어, 조엘 그린블라트(Joel Greenblatt)는 유명하게 두 요인 모델을 주식 순위를 매기는 "마법 공식(magic formula)"으로 사용했습니다: *f*(1) = 투하자본수익률(return on capital), *f*(2) = 이익 수익률(earnings yield) (Greenblatt, 2006). 우리는 상위 30개 순위의 주식을 매수하고 1년간 보유해야 합니다. 이 전략의 연간 수익률(APR)은 1988년부터 2004년까지 30.8%였으며, S&P 500의 12.4%와 비교됩니다. 선형성의 꽤 큰 승리입니다!

결국, 테스트 과정에서 아무리 조심스럽게 데이터 스누핑 편향을 방지하려 해도, 그것은 어떻게든 모델에 스며들 것입니다. 따라서 최종적이고 진정한 표본 외 테스트로서 워크포워드 테스트(walk-forward test)를 수행해야 합니다. 이 워크포워드 테스트는 모의 거래(paper trading) 형태로 수행될 수 있지만, 더 좋은 것은 모의 거래에서도 벗어난 전략의 측면을 테스트하기 위해 실제 자금(최소한의 레버리지)으로 거래되어야 합니다. 대부분의 트레이더들은 실시간 거래가 백테스트 값의 절반보다 나은 샤프 비율을 생성하면 만족할 것입니다.

### 주식 분할과 배당 조정 (Stock Splits and Dividend Adjustments)

회사의 주식이 $N$ 대 1 분할을 할 때마다, 주가는 *N*배로 나누어집니다. 그러나 분할 전에 해당 회사의 주식을 일정 수 보유하고 있었다면, 분할 후에는 *N*배 더 많은 주식을 소유하게 되므로 총 시장 가치에는 실제로 변화가 없습니다. 그러나 백테스트에서는 일반적으로 거래 신호를 결정하기 위해 어떤 가상 계정의 시장 가치 시계열이 아닌 가격 시계열만을 보고 있습니다. 따라서 분할 기준일(ex-date) 이전의 가격을 *N*으로 나누어 역조정하지 않으면, 기준일에 가격의 급격한 하락을 보게 되고, 이것이 일부 잘못된 거래 신호를 유발할 수 있습니다. 이는 백테스팅에서뿐만 아니라 실시간 거래에서도 마찬가지이므로, 실시간 거래 중에도 기준일에 시장이 열리기 직전에 과거 가격을 *N*으로 나누어야 합니다. (1 대 $N$ 역분할인 경우, 기준일 이전의 과거 가격에 *N*을 곱해야 합니다.)

마찬가지로, 회사가 주당 *d*의 현금(또는 주식) 배당을 지급할 때, 주가도 *d*만큼 하락합니다(다른 시장 움직임이 없는 경우). 이는 배당 기준일 이전에 해당 주식을 보유하고 있었다면 증권 계좌에 현금(또는 주식) 배분을 받게 되므로, 다시 총 시장 가치에 변화가 없어야 하기 때문입니다. 기준일 이전의 과거 가격 시계열을 역조정하지 않으면, 가격의 급격한 하락이 또한 잘못된 거래 신호를 유발할 수 있습니다. 이 조정 역시 기준일에 시장이 열리기 직전에 실시간 거래 모델에 사용되는 모든 과거 데이터에 적용되어야 합니다. (이 논의는 ETF에도 적용됩니다. 옵션 가격에는 약간 더 복잡한 처리가 필요합니다.)

많은 웹사이트에서 과거 분할 및 배당 정보를 찾을 수 있지만, earnings.com이 훌륭한 무료 자원입니다. 이 사이트는 과거 수치를 기록할 뿐만 아니라, 미래의 발표된 분할 및 배당 금액과 기준일도 보여주므로 자동 거래 소프트웨어에서 이러한 이벤트를 예측할 수 있습니다. 주식 분할과 배당이 이미 조정된 과거 주식 데이터에 관심이 있고 쉽게 다운로드하려면 csidata.com을 시도해 보세요.

### 주식 데이터베이스의 생존자 편향 (Survivorship Bias in Stock Database)

주식 거래 모델을 백테스팅하는 경우, 과거 데이터에 상장 폐지된 주식이 포함되어 있지 않으면 생존자 편향(survivorship bias)에 시달릴 것입니다. 극단적인 경우를 상상해 봅시다: 모델이 전일 가장 많이 하락한 주식 하나를 매수하고 영원히 보유하라고 요청한다고 가정합시다. 실제로 이 전략은 거의 확실히 저조한 성과를 낼 것입니다. 왜냐하면 많은 경우 전일 가장 많이 하락한 주식의 회사는 파산으로 이어져 주식 포지션의 100% 손실을 초래할 것이기 때문입니다. 그러나 과거 데이터에 상장 폐지된 주식이 포함되어 있지 않다면, 즉 오늘까지 생존한 주식만 포함한다면, 백테스트 결과는 훌륭해 보일 수 있습니다. 이는 크게 하락했지만 이후 생존한 주식을 매수했을 것이기 때문이며, 전략을 실시간으로 거래했다면 최종 생존을 예측할 수 없었을 것입니다.

생존자 편향은 평균 회귀 롱 온리(long-only) 주식 전략에 평균 회귀 롱-숏(long-short) 또는 숏 온리(short-only) 전략보다 더 위험합니다. 이는 앞서 본 바와 같이, 이 편향이 먼저 낮게 사서 나중에 높게 파는 롱 온리 전략의 백테스트 성과를 부풀리는 경향이 있는 반면, 먼저 높게 팔고 나중에 낮게 사는 숏 온리 전략의 백테스트 성과는 낮추기 때문입니다. 가격이 0으로 간 주식은 숏 온리 전략에서 매우 좋은 성과를 냈을 것이지만, 생존자 편향이 있는 백테스트 데이터에는 존재하지 않을 것입니다. 평균 회귀 롱-숏 전략의 경우, 두 효과는 반대 부호이지만, 롱 전략 수익률의 부풀림이 숏 포트폴리오 수익률의 감소보다 큰 경향이 있으므로 위험은 줄어들지만 제거되지는 않습니다. 생존자 편향은 모멘텀(momentum) 모델에는 덜 위험합니다. 수익성 있는 숏 모멘텀 거래는 생존자 편향이 있는 데이터에서 생략되는 경향이 있으므로, 백테스트 수익률이 감소합니다.

합리적인 가격으로 생존자 편향이 없는 과거 데이터를 csidata.com(상장 폐지된 주식 목록을 제공)에서 구매할 수 있습니다. 다른 업체로는 kibot.com, tickdata.com, crsp.com이 있습니다. 또는 매일 인덱스의 모든 주식의 과거 가격을 저장하여 자신만의 생존자 편향 없는 데이터를 수집할 수도 있습니다. 마지막으로, 이러한 생존자 편향 없는 데이터가 없는 경우, 피해를 줄이기 위해 가장 최근 3년 정도의 과거 데이터만으로 백테스팅을 제한할 수 있습니다.

### 1차 거래소 대 통합 주가 (Primary versus Consolidated Stock Prices)

많은 미국 주식은 뉴욕증권거래소(NYSE), NYSE Arca, 나스닥(Nasdaq), Island, BATS, Instinet, Liquidnet, Bloomberg Tradebook, Goldman Sachs의 Sigma X, Credit Suisse의 CrossFinder 등 여러 거래소, 전자 통신 네트워크(ECN), 다크 풀(dark pools)에서 거래됩니다. 주식의 과거 일일 종가를 조회하면, 이는 정규 거래 시간 동안 이러한 거래소 중 하나에서의 마지막 체결 가격을 반영합니다. 마찬가지로, 과거 일일 시가는 이러한 거래소 중 하나에서의 첫 번째 체결 가격을 반영합니다. 그러나 종가 시장가 주문(MOC) 또는 시가 시장가 주문(MOO)을 제출하면, 항상 1차 거래소(primary exchange)로만 라우팅됩니다. 예를 들어, IBM에 대한 MOC 주문은 NYSE로, SPY에 대한 MOC 주문은 NYSE Arca로, 마이크로소프트(MSFT)에 대한 MOC 주문은 나스닥으로 라우팅됩니다. 따라서 시가 시장가 또는 종가 시장가 주문에 의존하는 전략이 있다면, 모델을 정확하게 백테스트하기 위해 1차 거래소의 과거 가격이 필요합니다. 일반적인 통합 과거 가격을 백테스팅에 사용하면 결과가 상당히 비현실적일 수 있습니다. 특히, 통합 과거 가격을 사용하여 평균 회귀 모델을 백테스트하면 부풀려진 백테스트 성과를 생성할 가능성이 높습니다. 왜냐하면 소량의 주식이 1차 거래소의 경매 가격과 상당히 다른 가격으로 다른 거래소에서 체결될 수 있기 때문입니다. 다음 거래일의 거래 가격은 보통 이 달성하기 어려운 이상치 가격에서 평균으로 회귀할 것입니다. (미국 1차 거래소의 종가와 시가는 항상 경매에 의해 결정되는 반면, 2차 거래소에서의 종가 거래는 경매의 결과가 아닙니다.)

유사한 고려 사항이 전략에 고가나 저가를 사용하는 경우에도 적용됩니다. 과거 데이터에 기록된 것은 보통 통합 고가나 저가이지 1차 거래소의 것이 아닙니다. 이것들은 종종 2차 거래소에서의 소량 거래로 인한 대표성이 없는 과장된 수치입니다. 이러한 과거 가격을 사용하면 백테스트 성과도 부풀려질 것입니다.

1차 거래소의 과거 가격을 어디서 찾을 수 있을까요? 블룸버그(Bloomberg) 사용자는 구독의 일부로 이에 접근할 수 있습니다. 물론, 앞서 논의한 생존자 편향 없는 데이터를 저장하고 사용하는 경우와 마찬가지로, 거래소의 직접 실시간 피드를 구독하고 이러한 가격을 실시간으로 자체 데이터베이스에 저장할 수도 있습니다. 그런 다음 이러한 데이터베이스를 미래에 1차 거래소 데이터의 소스로 사용할 수 있습니다. 독립적으로 이러한 피드를 구독하는 것은 비용이 많이 들 수 있지만, 브로커가 이러한 구독을 가지고 있고 데이터 센터에 코로케이션하는 고객에게 재배포한다면 비용이 훨씬 낮을 수 있습니다. 불행히도, 대부분의 리테일 브로커는 거래소의 직접 피드를 재배포하지 않지만, Lime Brokerage와 같은 기관 브로커는 종종 그렇게 합니다.

이러한 데이터에 접근할 수 없다면, 우리가 할 수 있는 것은 백테스트 결과에 대한 건전한 회의론을 갖는 것뿐입니다.

### 통화 시세의 거래소 의존성 (Venue Dependence of Currency Quotes)

주식 시장과 비교하면, 통화 시장은 훨씬 더 파편화되어 있으며 한 거래소에서 체결된 거래가 모든 다른 거래소의 최우선 매수호가나 매도호가에서 이루어져야 한다는 규칙이 없습니다. 따라서 백테스트는 우리가 거래할 것으로 예상하는 것과 동일한 거래소에서 추출한 과거 데이터를 사용할 때만 현실적일 것입니다.

Streambase와 같은 시세 통합기가 다른 거래소의 데이터 피드를 하나의 주문장(order book)으로 통합합니다. 이 경우, 통합된 주문장의 일부를 형성한 거래소에서 실행할 수 있는 한, 통합 과거 데이터를 백테스팅에 사용할 수 있습니다.

통화 실시간 시세와 과거 데이터의 또 다른 특징은 거래 가격과 거래량이, 매수호가와 매도호가 시세와 달리, 일반적으로 이용할 수 없거나 최소한 약간의 지연 없이는 이용할 수 없다는 것입니다. 이는 딜러나 ECN이 거래 가격을 모든 시장 참가자에게 보고해야 한다는 규정이 없기 때문입니다. 실제로, 많은 딜러들은 거래 정보를 독점적이고 가치 있는 정보로 간주합니다. (7장에서 언급된 바와 같이 주문 흐름 정보에 의존하고 거래 가격을 요구하는 고빈도 전략이 있으므로 그들이 그렇게 하는 것이 현명할 수 있습니다. 은행의 외환 자기매매 데스크는 의심할 여지 없이 이 정보를 자신들만 보유하는 것을 선호합니다.) 그러나 동일한 통화쌍의 매수-매도 스프레드가 거래소 간에 상당히 다를 수 있으므로, 외환 전략의 백테스팅에는 매수-매도 시세를 사용하는 것이 어쨌든 권장됩니다. 결과적으로, 거래 비용도 거래소에 크게 의존하며 백테스트에서 고려해야 합니다.

### 공매도 제약 (Short-Sale Constraints)

공매도를 포함하는 주식 거래 모델은 해당 주식이 공매도될 수 있다고 가정하지만, 종종 일부 주식의 공매도에 어려움이 있습니다. 주식을 공매도하려면, 브로커가 다른 고객이나 다른 기관(일반적으로 많은 주식에 대해 대규모 롱 포지션을 가진 뮤추얼 펀드나 다른 자산 운용사)으로부터 해당 주식의 일정량을 "확보(locate)"하고 주식 대차를 주선할 수 있어야 합니다. 이미 큰 공매도 잔고가 존재하여 회사 주식의 많은 부분이 이미 대차되었거나, 주식의 유통 물량(float)이 제한적이라면, 주식이 "대차 곤란(hard to borrow)"일 수 있습니다. 대차 곤란은 공매도자로서 정상적인 상황과 반대로 주식 대여자에게 이자를 지불해야 함을 의미할 수 있습니다. 더 극단적인 경우, 대차 곤란은 원하는 수량이나 전혀 주식을 빌릴 수 없음을 의미할 수 있습니다. 2008-2009년 금융 위기 동안 리먼 브라더스(Lehman Brothers)가 붕괴한 후, 미국 증권거래위원회(SEC)는 수개월 동안 모든 금융 산업 주식의 공매도를 금지했습니다. 따라서 백테스팅 모델이 대차가 어렵거나 불가능한 주식을 공매도한다면, 다른 누구도 모델이 공매도할 때 주식을 공매도하여 가격을 하락시킬 수 없었기 때문에 놀라운 수익률을 보여줄 수 있습니다. 그러나 이 수익률은 완전히 비현실적입니다. 이것이 공매도 제약을 백테스팅에 위험하게 만듭니다. 그러나 백테스트를 위한 대차 곤란 주식의 역사적으로 정확한 목록을 찾는 것은 쉽지 않으며, 이 목록은 어떤 브로커를 사용하느냐에 따라 달라집니다. 일반적인 규칙으로, 소형주(small-cap stocks)는 대형주(large-cap stocks)보다 공매도 제약의 영향을 훨씬 더 많이 받으므로, 숏 포지션의 수익률이 훨씬 더 의심스럽습니다. ETF도 때로는 주식만큼 대차가 어려울 수 있다는 점도 유의하세요. 예를 들어, 리먼 브라더스 붕괴 후 수개월 동안 공매도하기 위해 SPY조차 빌릴 수 없었습니다!

추가적인 공매도 제약은 SEC가 부과한 이른바 "업틱 규칙(uptick rule)"입니다. 원래 업틱 규칙은 1938년부터 2007년까지 시행되었으며, 공매도는 마지막 거래 가격보다 높은 가격에서, 또는 그 가격이 마지막 이전 거래 가격보다 높았다면 마지막 거래 가격에서 실행되어야 했습니다. (나스닥 주식의 경우, 공매도 가격은 마지막 거래가 아닌 마지막 매수호가보다 높아야 합니다.) 2010년에 시행된 대안적 업틱 규칙(Alternative Uptick Rule)도 공매도가 전국 최우선 매수호가보다 높은 거래 가격을 가져야 하지만, 서킷 브레이커(circuit breaker)가 발동된 경우에만 적용됩니다. 주식의 서킷 브레이커는 해당 주식이 전일 종가보다 10% 낮게 거래되었을 때 발동됩니다. 서킷 브레이커는 최초 발동 이후 다음 날에도 효력이 있습니다. 이는 사실상 모든 공매도 시장가 주문의 체결을 방지합니다. 따라서, 다시 말해, 공매도를 포함하는 정말 정확한 백테스트는 과거 거래가 발생할 것으로 예정되었을 때 이러한 제약이 시행되고 있었는지를 고려해야 합니다. 그렇지 않으면 백테스트 성과가 부풀려질 것입니다.

### 선물 연속 계약 (Futures Continuous Contracts)

선물 계약은 만기일이 있으므로, 예를 들어 원유 선물에 대한 거래 전략은 실제로 많은 다른 계약에 대한 거래 전략입니다. 보통 전략은 최근월물(front-month) 계약에 적용됩니다. 어떤 계약이 "최근월물"인지는 정확히 언제 다음 월물로 "롤오버(roll over)"할 계획인지에 달려 있습니다. 즉, 현재 최근 계약을 매도하고 다음 가장 가까운 만기일의 계약을 매수할 계획(롱 포지션을 가지고 있다고 가정)인 시점에 달려 있습니다. 일부는 현재 최근 계약이 만료되기 10일 전에 롤오버하기로 결정할 수 있고; 다른 사람들은 "미결제 약정 교차(open interest crossover)" 시, 즉 다음 계약의 미결제 약정이 현재 최근 계약을 초과할 때 롤오버하기로 결정할 수 있습니다. 롤오버 날짜를 어떻게 결정하든, 이를 거래 전략에 통합하는 것은 상당한 추가 번거로움입니다. 이 매수와 매도는 전략과 무관하며 최소한의 추가 수익이나 손익(P&L)을 초래해야 합니다. (손익이나 수익률은 이른바 "롤 수익률(roll return)"의 영향을 받지만, 5장에서 광범위하게 논의하듯이, 롤 수익률은 사실상 매일 모든 계약에 효력이 있으며 롤오버의 결과가 아닙니다.) 다행히도, 대부분의 선물 과거 데이터 업체도 이를 인식하고, 보통 "연속 계약(continuous contract)" 데이터로 알려진 것을 제공합니다.

연속 계약을 직접 만드는 방법은 여기서 논의하지 않을 것입니다. 왜냐하면 많은 선물 과거 데이터 업체의 웹사이트에서 이에 대해 읽을 수 있기 때문입니다. 그러나 이 과정에서 알아야 할 뉘앙스가 있습니다. 연속 계약을 만드는 첫 번째 단계는 특정 롤오버 날짜 세트가 주어진 최근월물 계약의 가격을 연결하는 것입니다. 그러나 이것은 롤오버 이전 마지막 날짜에서 롤오버 날짜로 갈 때 상당한 가격 갭이 있을 수 있는 가격 시계열을 생성하며, 백테스트에서 롤오버 날짜에 잘못된 수익률이나 손익을 만들 것입니다.

이를 보기 위해, 날짜 *T*에서 최근 계약의 종가가 *p*(*T*)이고, 이 동일한 계약의 날짜 $T$ + 1에서의 종가가 *p*(*T* + 1)이라고 합시다. 또한, 날짜 $T$ + 1에서 다음 근월물 계약("원월물(back)" 계약이라고도 함)의 종가가 *q*(*T* + 1)이라고 합시다. $T$ + 1이 롤오버 날짜라고 가정하면, 최근 계약을 롱하고 있다면 종가에 이 계약을 *p*(*T* + 1)에 매도하고, 다음 계약을 *q*(*T* + 1)에 매수해야 합니다. $T$ + 1에서 이 전략의 손익(포인트, 달러가 아닌)과 수익률은 얼마일까요? 손익은 단순히 *p*(*T* + 1) - *p*(*T*)이고, 수익률은 (*p*(*T* + 1) - *p*(*T*))/*p*(*T*)입니다. 그러나 조정되지 않은 연속 가격 시계열은 *T*에서 *p*(*T*)의 가격과 $T$ + 1에서 *q*(*T* + 1)의 가격을 보여줄 것입니다. 손익과 수익률을 통상적인 방법으로 계산하면, *q*(*T* + 1) - *p*(*T*)와 (*q*(*T* + 1) - *p*(*T*))/*p*(*T*)라는 잘못된 값을 계산하게 될 것입니다. 이 오류를 방지하기 위해, 데이터 업체는 일반적으로 가격 갭을 제거하도록 데이터 시계열을 역조정하여 $T$ + 1에서의 손익이 *p*(*T* + 1) - *p*(*T*)가 되도록 합니다. 이는 $T$ 이전의 모든 날짜 *t*의 모든 가격 *p*(*t*)에 (*q*(*T* + 1) - *p*(*T* + 1))라는 수를 더하여 수행할 수 있으며, 그러면 *T*에서 $T$ + 1까지의 가격 변화와 손익이 *q*(*T* + 1) - (*p*(*T*) + *q*(*T* + 1) - *p*(*T* + 1)) = *p*(*T* + 1) - *p*(*T*)로 올바르게 계산됩니다. (물론, 모든 롤오버를 처리하려면, 데이터 시계열의 더 먼 과거로 갈수록 이 역조정을 여러 번 적용해야 합니다.)

문제가 해결되었을까요? 그렇지 않습니다. 조정된 가격 시계열에서 $T$ + 1의 수익률을 확인해 보세요: (*p*(*T* + 1) - *p*(*T*))/(*p*(*T*) + *q*(*T* + 1) - *p*(*T* + 1))이며, (*p*(*T* + 1) - *p*(*T*))/*p*(*T*)가 아닙니다. 손익 계산을 올바르게 하기 위해 역조정하면, 수익률 계산은 잘못된 채로 남게 됩니다. 반대로, 수익률 계산을 올바르게 하기 위해 가격 시계열을 역조정할 수 있지만(*T* 이전의 모든 날짜 *t*의 모든 가격 *p*(*t*)에 *q*(*T* + 1)/*p*(*T* + 1)이라는 수를 곱하여), 그러면 손익 계산이 잘못될 것입니다. 두 가지를 동시에 가질 수는 없습니다. 연속 계약 시계열을 사용하는 편의를 원하는 한, 하나의 성과 측정치, 손익 또는 수익률만 선택해야 합니다. (각 개별 계약에 대해 전략을 백테스트하고, 롤오버 매수와 매도를 직접 처리한다면, 손익과 수익률 모두 동시에 올바르게 계산할 수 있습니다.)

가격 역조정 대신 수익률 역조정 방법을 선택할 때 추가적인 어려움이 발생합니다: 먼 과거의 가격이 음수가 될 수 있습니다. 이는 거래 전략에 문제를 일으킬 수 있으며, 수익률 계산에 확실히 문제를 일으킬 것입니다. 이를 처리하는 일반적인 방법은 모든 가격에 상수를 더하여 음수가 되지 않도록 하는 것입니다.

올바른 역조정 방법을 선택하는 이 미묘함은 서로 다른 계약 간의 스프레드 거래를 포함하는 전략이 있을 때 더욱 중요합니다. 전략이 두 계약 간의 가격 차이에 기반하여 거래 신호를 생성한다면, 가격 역조정 방법을 선택해야 합니다; 그렇지 않으면 가격 차이가 잘못되어 잘못된 거래 신호를 생성할 수 있습니다. 전략이 캘린더 스프레드(calendar spreads, 동일한 기초 자산이지만 다른 만기일의 계약에 대한 스프레드)를 포함하는 경우, 이 역조정은 더욱 중요합니다. 이는 캘린더 스프레드가 스프레드의 한 레그 가격에 비해 작은 수이므로, 롤오버로 인한 오류가 스프레드의 상당한 비율이 될 것이며 백테스트와 실시간 거래 모두에서 잘못된 신호를 유발할 가능성이 매우 높기 때문입니다. 그러나 전략이 두 계약 간의 가격 비율에 기반하여 거래 신호를 생성한다면, 수익률 역조정 방법을 선택해야 합니다.

보시다시피, 과거 선물 가격에 대한 데이터 업체를 선택할 때, 역조정 문제를 정확히 어떻게 처리했는지 이해해야 합니다. 이는 확실히 백테스트에 영향을 미칩니다. 예를 들어, csidata.com은 가격 역조정만 사용하지만 음수 가격을 방지하기 위한 선택적 가산 상수가 있고, tickdata.com은 가격 대 수익률 역조정을 선택할 수 있는 옵션을 제공하지만 음수 가격을 방지하기 위한 상수를 추가하는 옵션은 없습니다.

### 선물 종가 대 정산 가격 (Futures Close versus Settlement Prices)

데이터 업체가 제공하는 선물 계약의 일일 종가는 보통 정산 가격(settlement price)이지, 그날 계약의 마지막 거래 가격이 아닙니다. 선물 계약은 (거래소에 의해 결정된) 매일 정산 가격을 가지며, 그날 계약이 전혀 거래되지 않았더라도 그렇습니다. 그리고 계약이 거래되었다면, 정산 가격은 일반적으로 마지막 거래 가격과 다릅니다. 대부분의 과거 데이터 업체는 정산 가격을 일일 종가로 제공합니다. 그러나 틱별 데이터를 제공하는 업체와 같은 일부 업체는 실제 거래 가격만 제공할 수 있으며, 따라서 그날 거래가 있었다면 종가는 마지막 거래 가격이 될 것입니다. 전략을 백테스트하기 위해 어떤 가격을 사용해야 할까요?

대부분의 경우, 정산 가격을 사용해야 합니다. 왜냐하면 종가 근처에서 실시간으로 거래했다면, 그것이 거래 가격에 가장 가까웠을 것이기 때문입니다. 마지막으로 기록된 거래 가격은 수시간 전에 발생했을 수 있으며 종가 근처의 거래 가격과 거의 관련이 없을 수 있습니다. 이는 선물에 대한 페어 트레이딩(pairs-trading) 전략을 구성하는 경우 특히 중요합니다. 정산 가격을 사용하여 선물 스프레드를 결정하면, 두 개의 동시 가격을 사용하고 있음이 보장됩니다. (이는 두 선물 계약이 동일한 기초 자산을 가지고 있어 동일한 마감 시간을 가지는 한 사실입니다. 시장 간 스프레드를 거래하는 경우, 이 섹션 끝부분의 논의를 참조하세요.) 그러나 마지막 거래 가격을 사용하여 스프레드를 결정하면, 매우 다른 시간에 생성된 가격을 사용하고 있을 수 있으며 따라서 부정확합니다. 이 부정확성은 백테스트 프로그램이 비현실적으로 큰 스프레드로 인해 잘못된 거래를 생성하고 있음을 의미할 수 있으며, 이러한 거래는 미래에 거의 동시에 발생하는 거래 시 스프레드가 올바르고 더 작은 값으로 돌아갈 때 백테스트에서 비현실적으로 수익성 있을 수 있습니다. 평소와 같이, 부풀려진 백테스트 결과는 위험합니다.

일중(intraday) 스프레드 전략이 있거나 스프레드 전략을 백테스팅하기 위해 일중 선물 가격을 사용하는 경우, 두 계약의 매수호가와 매도호가가 포함된 과거 데이터 또는 거래소에 네이티브한 스프레드 자체의 일중 데이터가 필요합니다. 이는 많은 선물 계약이 유동성이 높지 않기 때문에 필요합니다. 따라서 각 봉의 마지막 가격을 사용하여 스프레드를 형성하면, 동일한 봉에서 계약 A와 계약 B의 마지막 가격이 실제로 시간적으로 꽤 떨어진 거래를 참조할 수 있습니다. 비동기적 마지막 가격으로 형성된 스프레드는 실제로 그 가격에 매수하거나 매도할 수 없었을 것입니다. 스프레드의 각 레그의 마지막 가격 대신 스프레드 자체의 마지막 가격을 사용하는 일중 스프레드 전략의 백테스트는 다시 결과 수익률을 부풀릴 것입니다. 일중 과거 캘린더 스프레드 데이터(시세와 거래 가격 모두)를 판매하는 한 업체는 cqgdatafactory.com입니다.

시장 간 스프레드를 백테스팅할 때 간과해서는 안 될 일반적인 세부 사항이 하나 있습니다. 계약이 다른 거래소에서 거래되는 경우, 마감 시간이 다를 가능성이 높습니다. 따라서 종가를 사용하여 시장 간 스프레드를 형성하는 것은 잘못될 것입니다. 이는 선물과 ETF 사이의 스프레드를 형성하려는 경우에도 마찬가지입니다. 이에 대한 명백한 해결책은 동시성이 보장되도록 일중 매수-매도 데이터를 얻는 것입니다. 다른 가능성은 선물 자체 대신 선물을 보유하는 ETF를 거래하는 것입니다. 예를 들어, 금 선물 GC(정산 가격은 동부시간 오후 1시 30분에 설정)를 금광 ETF GDX에 대해 거래하는 대신, 금 신탁 GLD를 GDX에 대해 거래할 수 있습니다. 둘 다 Arca에서 거래되므로, 종가가 동일한 동부시간 오후 4시에 설정됩니다.

## 백테스팅의 통계적 유의성: 가설 검정 (Statistical Significance of Backtesting: Hypothesis Testing)

모든 백테스트에서 우리는 유한한 표본 크기의 문제에 직면합니다: 평균 수익률이나 최대 손실 등 어떤 통계적 측정치를 계산하든 무작위성에 영향을 받습니다. 다시 말해, 우리의 전략이 작은 데이터 표본에서 우연히 수익성이 있었을 수 있습니다. 통계학자들은 이 문제를 해결하기 위해 *가설 검정(hypothesis testing)*이라는 일반적인 방법론을 개발했습니다.

백테스팅에 적용되는 가설 검정의 일반적인 프레임워크는 다음 단계를 따릅니다:

- 1. 유한한 데이터 표본에 대한 백테스트를 기반으로, *검정 통계량(test statistic)*이라는 특정 통계적 측정치를 계산합니다. 구체적으로, 검정 통계량이 해당 기간 동안 거래 전략의 평균 일일 수익률이라고 합시다.
- 2. 무한한 데이터 세트에 기반한 실제 평균 일일 수익률이 실제로 0이라고 가정합니다. 이 가정을 *귀무가설(null hypothesis)*이라고 합니다.
- 3. 일일 수익률의 확률 분포가 알려져 있다고 가정합니다. 이 확률 분포는 귀무가설에 기반하여 평균이 0입니다. 이 확률 분포를 어떻게 결정하는지는 나중에 설명합니다.
- 4. 이 귀무가설 확률 분포에 기반하여, 평균 일일 수익률이 백테스트에서 관찰된 값 이상이 될 확률 *p*를 계산합니다(또는, 일반적인 검정 통계량의 경우, 음의 검정 통계량의 가능성을 허용하여 극단적인 값). 이 확률 *p*를 *p-값(p-value)*이라고 하며, 매우 작으면(예를 들어 0.01보다 작으면), 이는 "귀무가설을 기각"할 수 있으며, 백테스트된 평균 일일 수익률이 통계적으로 유의하다고 결론짓을 수 있음을 의미합니다.

이 절차에서 가장 많은 생각을 요하는 단계는 3단계입니다. 귀무가설 하에서 확률 분포를 어떻게 결정할까요? 아마도 일일 수익률이 평균이 0이고 표준편차가 일일 수익률의 표본 표준편차에 의해 주어지는 가우시안 분포와 같은 표준 매개변수 확률 분포를 따른다고 가정할 수 있습니다. 이렇게 하면, 백테스트가 높은 샤프 비율을 가지고 있다면 귀무가설을 매우 쉽게 기각할 수 있음이 분명합니다. 이는 가우시안 분포의 표준 검정 통계량이 다름 아닌 평균을 표준편차로 나누고 데이터 포인트 수의 제곱근을 곱한 것이기 때문입니다(Berntson, 2002). 다양한 임계값에 대한 *p*-값이 표 1.1에 나열되어 있습니다. 예를 들어, 일일 샤프 비율에 백테스트의 일수(*n*)의 제곱근을 곱한 값이 임계값 2.326 이상이면, *p*-값은 0.01 이하입니다.

이 가설 검정 방법은 높은 샤프 비율 전략이 더 통계적으로 유의하다는 우리의 믿음과 일치합니다.

귀무가설의 확률 분포를 추정하는 또 다른 방법은 몬테카를로 방법을 사용하여 시뮬레이션된 과거 가격 데이터를 생성하고 이 시뮬레이션된 데이터를 전략에 입력하여 수익의 경험적 확률 분포를 결정하는 것입니다. 우리의 믿음은 거래 전략의 수익성이 가격 시계열의 미묘한 패턴이나 상관관계를 포착한 것이지, 단지 가격 분포의 처음 몇 모멘트 때문이 아니라는 것입니다. 따라서 실제 가격 데이터와 동일한 처음 몇 모멘트와 동일한 길이를 가진 많은 시뮬레이션된 가격 시계열을 생성하고, 이 모든 시뮬레이션된 가격 시계열에 대해 거래 전략을 실행하면, 이 가격 시계열의 몇 분의 *p*에서 평균 수익률이 백테스트 수익률 이상인지 알 수 있습니다.

| 표 1.1 | sqrt(n) x 일일 샤프 비율의 임계값 |
|---------|----------------------------------|
| p-값    | 임계값                           |
| 0.10    | 1.282                            |
| 0.05    | 1.645                            |
| 0.01    | 2.326                            |
| 0.001   | 3.091                            |

*출처:* Berntson (2002).

이상적으로, *p*가 작아서 귀무가설을 기각할 수 있을 것입니다. 그렇지 않으면, 전략의 평균 수익률은 단지 시장 수익률에 기인한 것일 수 있습니다.

귀무가설의 확률 분포를 추정하는 세 번째 방법은 앤드류 로(Andrew Lo)와 그의 공동 연구자들이 제안한 것입니다(Lo, Mamaysky, and Wang, 2000). 이 방법에서는 시뮬레이션된 가격 데이터를 생성하는 대신, 시뮬레이션된 거래 세트를 생성하되, 롱과 숏 *진입* 거래의 수가 백테스트와 동일하고, 거래의 평균 보유 기간이 동일하다는 제약을 둡니다. 이 거래들은 실제 과거 가격 시계열에 무작위로 분포됩니다. 그런 다음 이러한 거래 세트 중 어떤 비율이 백테스트 평균 수익률 이상의 평균 수익률을 가지는지 측정합니다.

예제 1.1에서, 전략의 백테스트에 대한 통계적 유의성을 테스트하는 이 세 가지 방법을 비교합니다. 각각의 확률 분포가 다르고, 각 가정된 분포가 우리의 전략을 다른 무작위성 벤치마크와 비교하므로, 서로 다른 답을 주는 것은 놀라운 일이 아닙니다.

### 예제 1.1: 선물 모멘텀 전략에 대한 가설 검정 (Example 1.1: Hypothesis Testing on a Futures Momentum Strategy)

6장에서 설명된 TU 모멘텀 전략의 백테스트 결과에 각각 다른 귀무가설 확률 분포를 가진 세 가지 버전의 가설 검정을 적용합니다. 이 전략은 TU 선물이 양(음)의 12개월 수익률을 가지면 매수(매도)하고, 포지션을 1개월 보유합니다. 이 전략을 선택한 이유는 단순성 때문뿐만 아니라, 고정된 보유 기간을 가지기 때문입니다. 따라서 가설 검정의 버전 3에서는 보유 기간을 무작위화할 필요 없이 롱과 숏 거래의 시작일만 무작위화하면 됩니다.

첫 번째 가설 검정은 매우 쉽습니다. 귀무가설에 적합하게 평균이 0이고, 표준편차가 백테스트에서 주어진 일일 수익률의 표준편차인 가우시안 분포를 일일 수익률의 확률 분포로 가정합니다. 따라서 *ret*가 전략의 일일 수익률을 포함하는 Tx1 MATLAB 배열이라면, 검정 통계량은 단순히 다음과 같습니다:

우리 데이터 세트에서 이것은 2.93으로 나타납니다. 이 검정 통계량을 표 1.1의 임계값과 비교하면, 99% 이상의 확률로 귀무가설을 기각할 수 있음을 알 수 있습니다.

두 번째 가설 검정은 백테스트와 동일한 일수 동안 TU 선물(전략의 일일 수익률이 아닌)에 대한 무작위 시뮬레이션 일일 수익률 데이터 세트를 생성하는 것을 포함합니다. 이 무작위 일일 수익률 데이터는 관찰된 선물 수익률과 동일한 평균, 표준편차, 왜도, 첨도를 가지지만, 물론 동일한 상관관계가 내재되어 있지는 않습니다. 전략이 이 무작위 수익률 시계열에서 관찰된 수익률 시계열과 동일하거나 더 나은 수익률을 생성할 수 있는 좋은 확률이 있다면, 모멘텀 전략이 실제로 수익률의 모멘텀이나 직렬 상관관계를 포착하지 못하고 관찰된 수익률의 확률 분포가 특정 평균과 특정 형태를 가졌기 때문에 수익성이 있었음을 의미합니다. 처방된 모멘트를 가진 시뮬레이션된 무작위 수익률을 생성하기 위해 MATLAB Statistics Toolbox의 *pearsrnd* 함수를 사용합니다. 시뮬레이션된 수익률 *marketRet_sim*이 생성된 후, 이 수익률을 사용하여 시뮬레이션된 가격 시계열 *cl_sim*을 구성합니다. 마지막으로, 이 시뮬레이션된 가격에 대해 전략을 실행하고 전략의 평균 수익률을 계산합니다. 이를 10,000번 반복하고 전략이 관찰된 데이터 세트에서 생성된 것 이상의 평균 수익률을 생성하는 횟수를 셉니다.

*marketRet*가 TU의 관찰된 일일 수익률을 포함하는 Tx1 배열이라고 가정하면, 프로그램 조각은 아래에 표시됩니다. (이 테스트의 소스 코드는 [www.wiley.com/go/algotrading](http://www.wiley.com/go/algotrading)에서 *TU_mom_hypothesisTest.m*으로 다운로드할 수 있습니다.)

```matlab
moments={mean(marketRet), std(marketRet), ...
 skewness(marketRet), kurtosis(marketRet)};
numSampleAvgretBetterOrEqualObserved=0;
for sample=1:10000
    marketRet_sim=pearsrnd(moments{:}, length(marketRet), 1);
    cl_sim=cumprod(1+marketRet_sim)-1;
    longs_sim=cl_sim > backshift(lookback, cl_sim) ;
    shorts_sim=cl_sim < backshift(lookback, cl_sim) ;

pos_sim=zeros(length(cl_sim), 1);
       for h=0:holddays-1
           long_sim_lag=backshift(h, longs_sim);
           long_sim_lag(isnan(long_sim_lag))=false;
           long_sim_lag=logical(long_sim_lag);
           short_sim_lag=backshift(h, shorts_sim);
           short_sim_lag(isnan(short_sim_lag))=false;
           short_sim_lag=logical(short_sim_lag);
           pos_sim(long_sim_lag)=pos_sim(long_sim_lag)+1;
           pos_sim(short_sim_lag)=pos_sim(short_sim_lag)-1;
       end
       ret_sim=backshift(1, pos_sim).*marketRet_sim/holddays;
       ret_sim(~isfinite(ret_sim))=0;
  if (mean(ret_sim)>= mean(ret))
    numSampleAvgretBetterOrEqualObserved=numSampleAvgret
     BetterOrEqualObserved+1;
  end
end
```

10,000개의 무작위 수익률 세트 중 1,166개가 관찰된 평균 수익률 이상의 평균 전략 수익률을 가집니다. 따라서 귀무가설은 88%의 확률로만 기각할 수 있습니다. 분명히, 수익률 분포 곡선의 형태가 전략의 성공과 관련이 있습니다. (포지션이 다른 시간에 롱 또는 숏일 수 있으므로 성공이 분포의 평균 때문일 가능성은 낮습니다.)

세 번째 가설 검정은 백테스트에서와 동일한 수의 롱 거래와 숏 거래를 유지하면서 롱과 숏 진입 날짜를 무작위화하는 것을 포함합니다. 이는 MATLAB 함수 *randperm*으로 매우 쉽게 달성할 수 있습니다:

```matlab
numSampleAvgretBetterOrEqualObserved=0;
for sample=1:100000
    P=randperm(length(longs));

longs_sim=longs(P);
       shorts_sim=shorts(P);
       pos_sim=zeros(length(cl), 1);
       for h=0:holddays-1
           long_sim_lag=backshift(h, longs_sim);
           long_sim_lag(isnan(long_sim_lag))=false;
           long_sim_lag=logical(long_sim_lag);
           short_sim_lag=backshift(h, shorts_sim);
           short_sim_lag(isnan(short_sim_lag))=false;
           short_sim_lag=logical(short_sim_lag);
           pos(long_sim_lag)=pos(long_sim_lag)+1;
           pos(short_sim_lag)=pos(short_sim_lag)-1;
       end
       ret_sim=backshift(1, pos_sim).*marketRet/holddays;
       ret_sim(isnan(ret_sim))=0;
       if (mean(ret_sim)>= mean(ret))
       numSampleAvgretBetterOrEqualObserved=...
        numSampleAvgretBetterOrEqualObserved+1;
       end
end
```

100,000개의 표본 중 평균 전략 수익률이 관찰된 수익률 이상인 것은 단 하나도 없습니다. 분명히, 세 번째 테스트는 이 전략에 대해 훨씬 약합니다.

귀무가설이 유일하지 않고 다른 귀무가설이 다른 통계적 유의성 추정치를 제공할 수 있다는 사실은 많은 비평가들이 가설 검정이 결함 있는 방법론이라고 믿는 한 가지 이유입니다(Gill, 1999). 다른 이유는 우리가 실제로 알고 싶은 것은 검정 통계량 *R*을 관찰했을 때 귀무가설이 참일 조건부 확률: *P*(*H*0|*R*)이라는 것입니다. 그러나 우리가 앞서 설명한 절차는 실제로 귀무가설이 참일 때 검정 통계량 *R*을 얻을 조건부 확률만 계산했습니다: *P*(*R*|*H*0). *P*(*R*|*H*0) = *P*(*H*0|*R*)인 경우는 드뭅니다.

가설 검정과 귀무가설의 기각이 통계적 유의성을 추정하는 매우 만족스러운 방법이 아닐 수 있지만, 귀무가설을 기각하지 *못하는* 것은 매우 흥미로운 통찰을 줄 수 있습니다. 예제 1.1은 높은 첨도를 가진 모든 무작위 수익률 분포가 모멘텀 전략에 유리할 수 있음을 보여줍니다.

## 전략을 백테스트하지 말아야 할 때 (When Not to Backtest a Strategy)

앞서 모든 전략을 거래하기 전에 백테스트해야 한다고 설득하는 데 많은 노력을 기울였습니다. 왜 일부 전략에 대해 백테스팅을 권장하지 않을까요? 사실은 너무 명백하게 결함이 있어 고려할 가치도 없는 출판된 전략이 일부 있다는 것입니다. 백테스팅의 일반적인 함정에 대해 지금 알고 있는 것을 감안하면, 세부 사항을 모르고도 전략을 백테스트할 것인지 판단할 수 있는 좋은 위치에 있습니다. 여기서 몇 가지 예를 살펴보겠습니다.

**예제 1:** 백테스트 연간 수익률이 30%이고 샤프 비율이 0.3이며, 최대 손실 기간이 2년인 전략.

매우 적은 트레이더("투자자"와 달리)가 2년 동안 "물에 잠긴(under water)" 상태로 남아 있는 전략을 견딜 수 있습니다. 낮은 샤프 비율과 긴 손실 기간은 전략이 일관적이지 않음을 나타냅니다. 높은 평균 수익률은 단지 우연일 수 있으며, 전략을 실시간으로 거래하기 시작할 때 반복될 가능성이 낮습니다. 다른 말로 하면, 높은 수익률은 데이터 스누핑 편향의 결과일 가능성이 높으며, 긴 손실 기간은 전략이 교차 검증 테스트를 통과할 가능성을 낮춥니다. 높은 수익률이지만 낮은 샤프 비율의 전략을 백테스트하려 하지 마세요. 또한, 당신이나 투자자가 견딜 수 있는 것보다 긴 최대 손실 기간을 가진 전략을 백테스트하려 하지 마세요.

**예제 2:** 롱 온리 원유 선물 전략이 2007년에 20%의 수익률과 1.5의 샤프 비율을 기록했습니다.

2007년에 최근월물 원유 선물의 단순 보유 총 수익률을 빠르게 확인하면 47%였으며, 샤프 비율은 1.7이었습니다. 따라서 이 거래 전략은 어떤 면에서도 단순한 매수-보유(buy-and-hold) 전략보다 우수하지 않습니다! 교훈: 거래 전략을 측정하기 위해 항상 적절한 벤치마크를 선택해야 합니다. 롱 온리 전략의 적절한 벤치마크는 매수-보유 포지션의 수익률입니다 - 샤프 비율이 아닌 정보 비율(information ratio)입니다.

**예제 3:** 단순한 "저가 매수-고가 매도" 전략이 연초에 가장 낮은 가격의 10개 주식을 선택하여 1년간 보유합니다. 2001년의 백테스트 수익률은 388%입니다.

이 전략을 읽을 때 떠올라야 할 첫 번째 질문은: 전략이 생존자 편향이 없는(survivorship-bias-free) 주식 데이터베이스를 사용하여 백테스트되었는가? 입니다. 다시 말해, 주식 데이터베이스에 이후 상장 폐지된 주식이 포함되어 있는가? 데이터베이스에 오늘까지 생존한 주식만 포함되어 있다면, 전략은 2001년 초에 매우 저렴했던 운 좋은 생존자들을 선택할 가능성이 높습니다. 사후 확인의 이점으로, 백테스트는 물론 388%의 수익률을 달성할 수 있습니다. 반면, 데이터베이스에 상장 폐지된 주식이 포함되어 있다면, 전략은 포트폴리오를 구성하기 위해 그러한 주식을 선택할 가능성이 높아 거의 100% 손실을 초래합니다. 이 100% 손실이 2001년에 전략을 거래했다면 실현된 수익률이었을 것이며, 388%의 수익률은 결코 실현될 수 없는 부풀려진 백테스트 수익률입니다. 저자가 사용된 데이터에 상장 폐지된 주식이 포함되어 있다고 구체적으로 언급하지 않았다면, 백테스트가 생존자 편향으로 고통받고 있으며 수익률이 부풀려졌을 가능성이 높다고 가정할 수 있습니다.

**예제 4:** 약 100개의 노드를 가진 신경망 거래 모델이 백테스트 샤프 비율 6을 생성합니다.

*신경망 거래 모델*이라는 용어를 들을 때마다 항상 경보가 울립니다. 100개의 노드를 가진 것은 말할 것도 없습니다. 신경망의 노드에 대해 알아야 할 것은 표본 내 훈련 데이터로 적합시킬 매개변수의 수가 노드 수에 비례한다는 것뿐입니다. 최소 100개의 매개변수로, 원하는 어떤 시계열에도 모델을 적합시키고 환상적인 샤프 비율을 얻을 수 있습니다. 말할 필요도 없이, 데이터 스누핑 편향으로 인해 향후 예측력이 거의 또는 전혀 없을 것입니다.

**예제 5:** 고빈도 E-mini S&P 500 선물 거래 전략이 백테스트 연간 평균 수익률 200%와 샤프 비율 6을 가집니다. 평균 보유 기간은 50초입니다.

고빈도 거래 전략을 정말 백테스트할 수 있을까요? 고빈도 거래 전략의 성과는 사용된 주문 유형과 일반적인 실행 방법에 따라 달라집니다. 게다가, 시장 미시 구조(market microstructure)에 결정적으로 의존합니다. 전체 주문장의 과거 데이터가 있더라도, 고빈도 전략의 수익은 여전히 다른 시장 참가자의 반응에 매우 의존적입니다. "하이젠베르크 불확정성 원리(Heisenberg uncertainty principle)"가 작동하고 있는지 의문을 제기해야 합니다: 주문을 배치하거나 실행하는 행위가 다른 시장 참가자의 행동을 변경할 수 있습니다. 따라서 고빈도 전략의 이른바 백테스트에 매우 회의적이어야 합니다.

읽는 모든 전략을 백테스트하기에 인생은 너무 짧으므로, 백테스팅의 일반적인 함정에 대한 인식이 어떤 전략을 백테스트할지 선택하는 데 도움이 되기를 바랍니다.

## 백테스트가 미래 수익률을 예측할 수 있을까? (Will a Backtest Be Predictive of Future Returns?)

앞서 설명한 모든 일반적인 함정을 피하고 통계적 유의성을 보장할 충분한 거래가 있더라도, 모든 백테스트의 예측력은 가격 시계열의 통계적 속성이 변하지 않아 과거에 수익성 있었던 거래 규칙이 미래에도 수익성 있을 것이라는 핵심 가정에 달려 있습니다. 이 가정은 물론 다양한 정도로 종종 무효화됩니다: 국가의 경제 전망이 변하고, 회사의 경영진이 변하며, 금융 시장의 구조가 변합니다. 지난 10년간 미국에서 마지막 범주의 변화에 대한 수많은 사례를 목격했습니다. 그 중에는:

- 2001년 4월 9일 미국 주식 시세의 십진법화(decimalization). (이 날짜 이전에는 미국 주식이 1/8 또는 1/16 페니 단위로 시세가 표시되었습니다.) 이로 인해 매수-매도 스프레드가 감소했지만, 최우선 매수호가와 매도호가에서의 "표시된 유동성(displayed liquidity)"도 감소했습니다(Arnuk and Saluzzi, 2012). 이는 차례로 많은 통계적 차익거래 전략의 수익성을 감소시키면서 많은 고빈도 전략의 수익성을 증가시켰습니다.
- 평균 일일 거래량의 50% 감소를 유발한 2008년 금융 위기(Durden, 2012). 리테일 거래와 보통주 소유가 특히 줄었습니다. 이는 시장의 평균 변동성을 감소시켰지만, 2010년 5월의 플래시 크래시(flash crash)와 2011년 8월의 미국 연방 부채 신용 등급 하향 조정과 같은 갑작스러운 폭발의 빈도를 증가시켰습니다. 전반적인 효과는 높지만 일정한 수준의 변동성에서 번영하는 평균 회귀 전략의 수익 일반적 감소였습니다.
- 6장에서 논의된 바와 같이, 모멘텀 전략의 다년간 약세장을 시작한 동일한 2008년 금융 위기.
- 평균 거래 규모의 급격한 감소와 NYSE 블록 거래의 쇠퇴에 기여한 SEC의 Regulation NMS(2007년 7월 시행)(Arnuk and Saluzzi, 2012).
- 2007년 6월 공매도에 대한 기존 업틱 규칙의 제거와 2010년 새로운 대안적 업틱 규칙의 재시행.

이러한 각 "체제 전환(regime shifts)" 이전에 탁월하게 수행되었던 전략은 수행을 멈출 수 있고 그 반대도 마찬가지입니다. 이러한 체제 전환 이전의 데이터를 사용한 백테스트는 상당히 무가치할 수 있으며, 최근 데이터를 사용한 백테스트도 미래의 체제 전환이 발생할 경우 미래 수익을 더 이상 나타내지 않을 수 있습니다. 이것의 일반적인 요점은 알고리즘 거래가 알고리즘, 프로그래밍, 수학에 관한 것만이 아니라는 것입니다: 백테스트가 예측적이며 계속 예측적일지에 대해 알려주기 위해 이러한 근본적인 시장과 경제 문제에 대한 인식도 필요합니다.

## 백테스팅 및 자동 실행 플랫폼 선택 (Choosing a Backtesting and Automated Execution Platform)

소프트웨어 회사들은 트레이더들에게 가능한 모든 수준의 프로그래밍 기술에 맞는 다양한 백테스팅 및 자동 실행 플랫폼을 제공하기 위해 매우 열심히 노력해 왔습니다. 거래 플랫폼을 결정할 때 두 가지 기본 선택에 직면합니다:

- 1. 특수 목적 백테스팅 및 실행 플랫폼을 구매하고, 해당 플랫폼의 특수 목적 그래픽 사용자 인터페이스(GUI) 또는 프로그래밍 언어를 사용하여 전략을 구현하는 것.
- 2. C++와 같은 범용 프로그래밍 언어로 자체 백테스트 및 실행 프로그램을 작성하는 것. 이는 작업을 쉽게 하기 위해 소프트웨어 라이브러리를 개별적으로 구매하여 완전히 독립적인 방식으로 하거나, 알고리즘 거래에 맞춤화된 포괄적인 라이브러리가 포함된 통합 개발 환경(IDE) 내에서 할 수 있습니다.

다음으로 이 선택을 위한 몇 가지 기준을 고려합니다.

### 프로그래밍 기술은 얼마나 좋은가? (How Good Is Your Programming Skill?)

프로그래밍 기술이 거의 없다면, 유일한 선택은 특수 목적 거래 플랫폼을 선택하는 것입니다. 이러한 플랫폼은 거래 전략을 구축하기 위한 그래픽 "드래그 앤 드롭" 사용자 인터페이스를 제시하여 사용자가 프로그래밍 언어를 배워야 하는 부담을 덜어줍니다. 이러한 제품의 예로는 Deltix와 Progress Apama가 있습니다. 그러나 이러한 GUI는 구축할 수 있는 전략의 다양성에서 상당히 제한적일 수 있으며, 장기적으로는 전략을 표현하기 위해 프로그래밍 언어에 능숙해지는 것이 훨씬 더 효율적입니다. (Deltix와 Progress Apama는 아래에 설명된 대로 전략을 지정하는 다른 방법도 허용합니다.)

다음 수준의 프로그래밍 기술을 가진 트레이더는 스크립팅 언어(scripting languages) 중 하나를 사용하여 백테스팅과 자동 실행을 모두 구현하는 것을 고려해야 합니다. 이 언어들은 컴파일이 필요 없으며, 수학적 또는 논리적 표현을 입력하는 순간 즉시 결과를 볼 수 있습니다. 많은 트레이더들이 가장 좋아하는 백테스팅 플랫폼인 마이크로소프트 엑셀(Microsoft Excel), 아마도 비주얼 베이직(VB) 매크로와 함께 사용되는 것이 이 범주에 속합니다. 그러나 엑셀에서 합리적으로 복잡한 전략을 구축하는 것은 실제로 상당히 어렵고, 디버깅하기는 더욱 어렵습니다. 엑셀은 또한 특별히 고성능 언어가 아니므로, 전략이 매우 계산 집약적이라면 작동하지 않을 것입니다. 자동 실행에 엑셀을 사용하는 경우, 시장 데이터 업데이트를 위해 브로커가 제공하는 DDE 링크를 사용해야 할 수 있으며, 더 복잡한 거래 로직을 처리하기 위해 비주얼 베이직 매크로를 추가해야 할 가능성이 높으며, 이는 상당히 비효율적입니다. (그러나 효율성을 위해 강화된 엑셀 유사 거래 플랫폼에 대해서는 박스 1.1을 참조하세요.)

#### 스테로이드를 맞은 엑셀 - FXone 자동 실행 플랫폼 (Excel on Steroids - The FXone Automated Execution Platform)

엑셀처럼 보이지만, 기본 계산 엔진이 VB 매크로에 의존하지 않고 C++와 같은 고성능 언어로 작성된 FXone이라는 통화 거래 플랫폼이 있습니다. 이것은 진정한 틱 구동 애플리케이션입니다: 모든 틱(FX의 경우, 틱은 새로운 시세)이 스프레드시트의 모든 셀에 있는 모든 값의 재계산을 유발합니다. 게다가, 동일한 데이터를 계산하는 데 필요한 다른 셀이 동일한 데이터 구독을 복제하는 대신 캐시에서 단순히 검색할 수 있도록 실시간 데이터를 위한 내부 캐시가 있습니다. 이것은 또한 두 가지 다른 수준에서 진정한 멀티스레드 플랫폼입니다. 첫째, 다른 엑셀 워크북에 작성된 다른 전략이 시장 데이터 업데이트를 받고 동시에 주문을 제출할 수 있습니다. 둘째, 동일한 워크북 내의 다른 셀도 동시에 업데이트를 받고 새로운 데이터에 대해 행동할 수 있습니다. 즉, 한 셀의 계산이 완료되는 데 매우 오래 걸리더라도, 다른 셀이 새로운 틱에 응답하여 예를 들어 주문을 제출하는 것을 방지하지 않습니다. FXone의 스크린샷은 그림 1.1에 나와 있습니다.

![](_page_26_Figure_2.jpeg)

**그림 1.1** FXone 스크린샷.

QuantHouse, RTD Tango, 그리고 앞서 언급한 Deltix와 Progress Apama를 포함한 많은 특수 목적 거래 플랫폼은 비주얼 베이직만큼 간단하고 배우기 쉬운 자체 독점 프로그래밍 언어로 전략을 코딩하는 방법도 포함하고 있습니다. 여기서 언급된 기관 플랫폼 외에도, 많은 리테일 트레이더들은 MetaTrader, NinjaTrader, Trading Blox, 또는 TradeStation Easy Language에 익숙합니다. 이 모든 플랫폼을 개인적으로 시도해 보지는 않았지만, 명백한 사용 편의성과 나중에 언급할 다른 장점에도 불구하고, 이들 모두가 어떤 식으로든 백테스트하고 실행할 수 있는 전략의 유형에 일부 제한을 두고 있다는 의심이 남아 있습니다.

VB보다 약간 더 많은 기술을 요구하는 것으로, 트레이더들은 MATLAB, R, Python의 스크립팅 언어가 디버깅의 훨씬 더 큰 용이성, 백테스트할 수 있는 전략 유형의 훨씬 더 큰 유연성, 대규모 데이터 세트를 백테스팅하는 더 높은 효율성을 제공한다는 것을 알게 될 것입니다. 이것들을 "REPL" 언어라고 합니다. REPL은 프로그래머 용어로 "Read-Eval-Print-Loop"입니다. 즉, 수학적 표현을 입력하면 프로그램이 즉시 평가하고 답을 출력하며, 다음 표현을 입력할 준비를 합니다. 휴대용 계산기처럼 작동하지만 더 나은 것입니다: 이 모든 표현을 파일에 저장하고 프로그램이 자동으로 순차적으로 실행하게 할 수도 있습니다. 이 언어들의 구문은 C++와 같은 전통적인 프로그래밍 언어보다 더 직관적이고 이해하기 쉽게 설계되었으며, 프로그램에서 사용할 수 있는 변수 유형 면에서 훨씬 더 유연합니다. 스칼라, 배열, 문자열 모두 기본적으로 유사한 구문을 사용하여 처리되고 동일한 방식으로 함수에 전달됩니다.

MATLAB은 또한 Java, C++, 또는 C# 라이브러리나 API(응용 프로그래밍 인터페이스)를 활용하고 이러한 라이브러리나 API에 구현된 함수를 호출할 수 있습니다. 이는 작업이 특히 계산 집약적일 때 MATLAB이 전통적인 언어의 더 효율적인 구현을 활용할 수 있게 합니다. 또한, MATLAB, R, 또는 Python으로 작성된 것보다 전통적인 언어로 작성된 라이브러리와 API가 훨씬 더 많으므로, 이 기능은 종종 필수적입니다.

많은 알고리즘 트레이더들은 MATLAB, R, Python이 백테스팅에 훌륭한 언어라는 것을 알고 있습니다. 그러나 덜 알려진 것은 일부 도구 상자를 추가하면 실행 플랫폼으로도 전환할 수 있다는 사실입니다. 대부분의 브로커는 Java, C++, 또는 C#로 작성된 API를 가지고 있으며, 앞서 말했듯이 MATLAB은 이러한 언어로 작성된 API의 함수를 호출할 수 있지만, 이러한 함수를 호출하는 방법을 알기 위해서는 이러한 언어에 어느 정도 익숙해야 합니다. MATLAB에서 "외국어" API 호출을 하지 않아도 되는 솔루션을 선호한다면, 여러 상용 제품이 있습니다. MATLAB 자체의 Datafeed Toolbox는 Trading Technologies의 X_TRADER로 주문을 보낼 수 있습니다. MATLAB을 Interactive Brokers에 연결하기 위해, undocumentedmatlab.com은 IB-Matlab이라는 API를 개발했습니다. 다른 업체인 www.exchangeapi.com은 quant2ib라는 유사한 API와 MATLAB을 Trading Technologies에 연결하기 위한 quant2tt를 보유하고 있습니다. 다른 브로커의 경우, www.pracplay.com은 월간 요금으로 MATLAB이나 R에서 15개 이상의 브로커로의 브릿지를 제공합니다. Interactive Brokers에 연결하기 위한 무료 오픈소스 MATLAB API는 Jev Kuznetsov가 개발했으며 MATLAB Central의 File Exchange에서 다운로드할 수 있습니다. 한편, agoratron.com의 MAT-FIX 소프트웨어는 MATLAB 프로그램이 FIX(Financial Information eXchange) 프로토콜을 사용하여 브로커나 거래소로 주문을 보낼 수 있게 합니다. 또한 MATLAB을 사용하여 오픈소스 FIX 엔진인 QuickFIX의 Java나 .NET 함수를 호출할 수도 있습니다(Kozola, 2012). Python 사용자를 위해, 무료 오픈소스 소프트웨어 IbPy가 Python 거래 프로그램을 Interactive Brokers에 연결합니다. 이러한 MATLAB과 Python의 추가 기능이 브로커에 연결하는 것을 가능하게 하지만, 그러한 연결의 모든 복잡성으로부터 보호해 주지는 않습니다. 그리고 더 중요하게, 백테스팅과 실행 모두에 동일한 프로그램을 사용하는 것이 번거롭습니다.

하드코어 프로그래머라면, 물론 가장 유연하고 가장 효율적이며 가장 강건한 프로그래밍 언어인 앞서 언급한 Java, C++, C# 트리오로 직접 백테스팅과 자동 실행을 하는 데 문제가 없을 것입니다. 앞서 말했듯이, 알고리즘 트레이더를 대상으로 하는 모든 브로커나 거래소는 이러한 언어 중 하나 이상의 API를 제공하거나, 이러한 언어 중 하나로 작성된 프로그램을 사용하여 생성하고 전송할 수 있는 FIX 메시지를 사용하여 주문을 제출할 수 있게 합니다. (예를 들어, 앞서 언급한 QuickFIX는 C++, C#, VB, Python, Ruby에서 사용 가능합니다.) 그러나 여기서도 소프트웨어 산업은 백테스팅을 위해 특별히 설계된 IDE를 제공하여 전략 구현을 더 쉽고 강건하게 만들기 위해 왔습니다. 사실, 많은 특수 목적 거래 플랫폼(Deltix, Progress Apama, QuantHouse, RTD Tango 등)은 범용 고급 프로그래밍 언어를 사용하여 전략을 코딩하는 방법을 포함하여 IDE와 유사하게 만듭니다. 다음 섹션에서 설명하는 무료 오픈소스 클래스 라이브러리나 IDE도 있습니다.

### 백테스팅과 실행이 동일한 프로그램을 사용할 수 있는가? (Can Backtesting and Execution Use the Same Program?)

특수 목적 *실행* 플랫폼은 일반적으로 브로커나 거래소에 연결하고, 실시간 시장 데이터를 수신하고, 주문을 보내고 주문 확인을 수신하고, 포트폴리오 포지션을 업데이트하는 등의 복잡성을 프로그래머에게 숨깁니다. 한편, 특수 목적 *백테스팅* 플랫폼은 일반적으로 과거 데이터와 통합되어 있습니다. 따라서 많은 특수 목적 거래 플랫폼의 경우, 데이터를 검색하는 방법이나 주문을 어디에 제출하는지의 세부 사항에 방해받지 않는 순수한 거래 로직을 함수로 분리하고, 과거 데이터 대 실시간 시장 데이터를 입력하는 것을 전환하는 버튼을 눌러 백테스팅 모드와 실시간 실행 모드 간에 전환할 수 있으므로, 백테스트 프로그램을 실시간 실행 프로그램과 동일하게 만들 수 있습니다.

백테스팅과 실시간 실행 간의 이 전환 용이성은 단순한 편의 이상입니다: 백테스트 전략을 실시간 전략으로 전사하는 과정에서의 불일치나 오류의 가능성을 제거하며, 이러한 불일치는 C++이든 MATLAB이든 범용 프로그래밍 언어로 작성된 전략을 종종 괴롭힙니다. 마찬가지로 중요하게, 선행 편향의 가능성을 제거합니다. 앞서 설명한 바와 같이, 선행 편향은 미래의, 알 수 없는 정보를 백테스트 엔진에 대한 과거 데이터 입력의 일부로 잘못 포함하는 것을 의미합니다. 특수 목적 플랫폼은 실시간 시장 데이터를 공급하는 것처럼 한 번에 하나의 틱이나 하나의 봉씩 과거 시장 데이터를 거래 생성 엔진에 입력합니다. 따라서 미래 정보가 입력으로 사용될 가능성이 없습니다. 이것이 특수 목적 거래 플랫폼을 사용하는 하나의 주요 장점입니다.

백테스팅과 실시간 실행 프로그램이 동일한 플랫폼을 사용하는 것의 한 가지 더 장점이 있습니다 - 진정한 틱 기반 고빈도 거래 전략 백테스팅을 가능하게 합니다. 이는 대부분의 산업 수준 실시간 실행 프로그램이 "이벤트 구동(event-driven)"이기 때문입니다; 즉, 거래는 임의의 시간 봉의 끝이 아니라 새로운 틱의 도착에 의해 유발됩니다. 따라서 입력 과거 데이터도 틱 기반이라면, 모든 틱의 변화나 심지어 주문장의 모든 변화에 의존하는 고빈도 전략도 백테스트할 수 있습니다. (하드웨어가 충분히 강력하다고 가정하여 "이론적으로"라고 했습니다. 그렇지 않은 경우, 이 장의 뒷부분 "플랫폼은 어떤 유형의 자산 클래스나 전략을 지원하는가?" 섹션의 논의를 참조하세요.) 물론, 모든 틱을 프로그램에 입력하여 MATLAB에서도 틱 기반 전략을 백테스트할 수 있지만, 이는 상당히 번거로운 절차입니다.

**표 1.2 백테스팅 및 자동 실행을 위한 오픈소스 통합 개발 환경(IDE) 비교**

| IDE          | 언어                                           | 자산 클래스 | 브로커                                                 | 틱 기반? | CEP 지원? |
|--------------|------------------------------------------------|-------------|--------------------------------------------------------|----------|-----------|
| ActiveQuant  | Java, MATLAB, R                                | 다양        | CTS, FIX, Trading Technologies 지원 브로커             | 예       | 아니오    |
| Algo-Trader  | Java                                           | 다양        | Interactive Brokers, FIX                               | 예       | 예        |
| Marketcetera | Java, Python, Ruby                             | 다양        | 다양, FIX                                              | 예       | 예        |
| OpenQuant    | .NET (C#, VB)                                  | 다양        | 다양, FIX                                              | ?        | 아니오    |
| TradeLink    | .NET (C#, C++, VB), Java, Pascal, Python       | 다양        | 다양, FIX                                              | 예       | 아니오    |

범용 프로그래밍 언어의 유연성을 선호하면서도 앞의 고려 사항 때문에 백테스팅과 실시간 거래 모두에 동일한 프로그램을 사용하고 싶은 유능한 프로그래머라면, 기관급 특수 목적 플랫폼을 IDE로 사용할 수도 있고, 많은 오픈소스 IDE를 사용할 수도 있습니다: Marketcetera, TradeLink, Algo-Trader, ActiveQuant. IDE라고 부르지만, 단순한 거래 전략 개발 환경 이상입니다: 특수 목적 플랫폼처럼 브로커에 연결하고 데이터를 교환하는 세부적인 작업을 처리하는 라이브러리가 함께 제공됩니다. 많은 것들이 과거 데이터와도 통합되어 있어 중요한 시간 절약이 됩니다. 추가 보너스로, 이러한 오픈소스 IDE는 특수 목적 플랫폼에 비해 무료이거나 상당히 저렴합니다. 표 1.2에 그들이 지원하는 언어, 시장, 브로커를 표시합니다. (브로커로서의 FIX는 시스템이 청산 브로커에 관계없이 FIX 프로토콜을 통해 모든 실행 장소에 직접 접근할 수 있음을 의미합니다.) 또한 IDE가 틱 기반(때로는 *이벤트 구동* 또는 *스트림 기반*이라고 함)인지도 표시합니다.

표 1.2는 오픈소스 IDE의 기능만 비교한다는 점에 유의해야 합니다. 기관급 특수 목적 플랫폼은 일반적으로 이러한 모든 기능을 갖추고 있습니다.

### 플랫폼은 어떤 유형의 자산 클래스나 전략을 지원하는가? (What Type of Asset Classes or Strategies Does the Platform Support?)

거래 전략에 특수 목적 플랫폼을 사용하는 것이 앞서 설명한 몇 가지 중요한 장점을 가지고 있지만, 최고급 플랫폼을 제외하고는 주식, 선물, 통화, 옵션을 포함한 모든 가능한 자산 클래스를 지원하는 것이 거의 없습니다. 예를 들어, 인기 있는 MetaTrader는 통화 거래만을 위한 것입니다. 이러한 플랫폼이 선물과 주식, 또는 통화와 선물 같은 다른 자산 클래스 간의 차익거래를 포함하는 전략을 거래하는 것은 특히 어렵습니다. 오픈소스 IDE는 이러한 상황을 더 잘 처리할 수 있습니다. 표 1.2에서 볼 수 있듯이, 대부분의 IDE는 다양한 자산 클래스를 거래할 수 있습니다. 그러나 평소와 같이, 이 점에서 가장 유연한 솔루션은 IDE 외부에서 작성된 독립 프로그램입니다.

자산 클래스를 넘어, 많은 특수 목적 플랫폼은 하나의 자산 클래스 내에서도 지원하는 전략 유형에 제한을 둡니다. 종종 단순한 페어 트레이딩 전략도 처리하기 위한 특별 모듈이 필요합니다. 대부분의 저가 플랫폼은 많은 종목을 포함하는 일반적인 통계적 차익거래나 포트폴리오 거래 전략을 처리할 수 없습니다. 오픈소스 IDE에는 이러한 제한이 없으며, 물론 독립 프로그램에도 없습니다.

고(빈도) 거래는 어떨까요? 어떤 종류의 플랫폼이 이 요구 까다로운 거래 전략을 지원할 수 있을까요? 놀라운 답은 대부분의 플랫폼이 고빈도 거래의 실행 부분을 너무 많은 지연 없이 처리할 수 있다는 것입니다(전략이 1~10밀리초 범위의 지연을 견딜 수 있는 한). 특수 목적 플랫폼과 IDE는 일반적으로 백테스팅과 실행 모두에 동일한 프로그램을 사용하므로, 이론적으로 백테스팅도 문제가 되지 않아야 합니다.

왜 대부분의 플랫폼이 고빈도 실행을 처리하는 데 문제가 없는지 이해하려면, 고빈도 거래에서 극복해야 할 대부분의 지연이 실시간 시장 데이터 지연이나 브로커 주문 확인 지연에 기인한다는 것을 인식해야 합니다.

#### 1. 실시간 시장 데이터 지연:

프로그램이 1~10밀리초(ms) 이내에 새로운 시세나 거래 가격을 수신하려면, 프로그램을 거래소에 또는 브로커의 데이터 센터에 코로케이션해야 합니다(박스 1.2 참조). 게다가, SIAC의 CTS(Consolidated Tape System)와 같은 통합 데이터 피드가 아닌 관련 거래소에서 직접 데이터 피드를 수신해야 합니다. (예를 들어, Interactive Brokers의 데이터 피드는 250ms마다 시장 데이터의 스냅샷만 제공합니다.)

#### 2. 브로커 주문 확인 지연:

전략이 지정가 주문을 제출하는 경우, 다음에 무엇을 할지 결정하기 전에 적시 주문 상태 확인에 의존합니다. 일부 리테일 브로커의 경우, 주문 실행과 프로그램의 실행 확인 수신 사이에 최대 6초가 걸릴 수 있으며, 이는 고빈도 거래가 불가능함을 사실상 보장합니다. 브로커의 주문 확인 지연이 10ms 미만이거나, 거래소에 직접 시장 접근을 허용하여 거래소에서 직접 주문 상태 확인을 받더라도, 전자의 경우 브로커와, 후자의 경우 거래소와 프로그램을 코로케이션해야 합니다.

#### 거래 프로그램의 코로케이션 (Colocation of Trading Programs)

코로케이션(colocation)이라는 일반적인 용어는 데스크톱 컴퓨터 외부에 거래 프로그램을 물리적으로 배치하는 여러 방법을 의미할 수 있습니다. 정의를 약간 확장하면, Amazon의 EC2, slicehost.com, 또는 gogrid.com과 같은 클라우드 서버나 VPS(가상 사설 서버)에 거래 프로그램을 설치하는 것을 의미할 수 있습니다. 이렇게 하는 이점은 백업 전원 공급 장치와 중복 네트워크 연결을 갖춘 상업 데이터 센터보다 개인 가정이나 사무실에서 발생할 가능성이 더 높은 전력 또는 인터넷 중단을 방지하는 것입니다. 클라우드 서버에 코로케이션하는 것이 반드시 브로커나 거래소에서 거래 프로그램으로의 데이터 이동 시간을 단축시키지는 않습니다. 많은 가정이나 사무실이 이제 인터넷 서비스 제공자에 광섬유 연결을 갖추고 있기 때문입니다(예: 미국의 Verizon FiOS, 캐나다의 Bell Fibe Internet). VPS에 코로케이션하는 것이 실제로 이 지연을 줄이는지 확인하려면, 브로커 서버에 "핑(pinging)"하여 평균 왕복 시간이 얼마인지 직접 테스트해야 합니다. 확실히, VPS가 물리적으로 브로커나 거래소에 가까이 위치하고, 인터넷 백본에 직접 연결되어 있다면, 이 지연은 더 작을 것입니다. (예를 들어, 데스크톱 컴퓨터에서 Interactive Brokers의 시세 서버를 핑하면 평균 왕복 시간이 약 55ms이고, Amazon의 EC2에서 동일한 서버를 핑하면 약 25ms, Interactive Brokers 근처에 위치한 다양한 VPS에서 핑하면 약 16~34ms입니다.)

VPS를 언급하는 이유는 많은 거래 프로그램이 자체 전용 서버가 필요할 정도로 계산 집약적이지 않기 때문입니다. 그러나 그렇다면, Equinix와 Telx와 같은 금융 거래 산업의 요구 사항에 익숙한 많은 호스팅 회사에서 확실히 이러한 서비스로 업그레이드할 수 있으며, 두 회사 모두 다양한 거래소에 근접한 데이터 센터를 운영합니다.

서버가 이미 안전한 장소(사무실이든 데이터 센터든)에 있고 전력 중단에 면역이라면, 필요한 것은 브로커나 거래소에 대한 빠른 연결뿐입니다. 공공 인터넷과 같지만 최소 통신 속도를 보장하는 사설 회사가 운영하는 "엑스트라넷(extranet)"을 사용하는 것을 고려할 수 있습니다. BT Radianz, Savvis, TNS가 그러한 회사의 예입니다. 큰 예산이 있다면, 이 회사들에 서버에서 브로커나 거래소까지 전용 통신 회선을 구축하도록 요청할 수도 있습니다.

코로케이션 계층의 다음 단계는 브로커의 데이터 센터 내에 코로케이션하여, 브로커가 생성한 시세나 주문 확인이 공공 인터넷의 잡음과 변덕에 방해받지 않고 내부 네트워크를 통해 프로그램에 전송되도록 하는 것입니다. 전문 트레이더를 대상으로 하는 다양한 브로커가 코로케이션 서비스를 제공하고 있습니다: 예로는 Lime Brokerage와 FXCM이 있습니다. (코로케이션 덕분에, Lime Brokerage의 고객은 앞서 언급한 바와 같이 통합 SIAC CTS 데이터 피드보다 빠른 NYSE에서 직접 데이터 피드를 상대적으로 저렴한 비용으로 수신할 수 있습니다.)

궁극적인 코로케이션은 물론 거래 서버를 거래소나 ECN 자체에 배치하는 것입니다. 이는 (외환 ECN을 제외하고는) 비용이 많이 드는 제안이 될 가능성이 높으며, 프라임 브로커 관계가 있는 경우에만 유용합니다. 이를 통해 브로커의 인프라를 거치지 않고 거래소에 연결하는 "스폰서드 액세스(sponsored access)"를 가질 수 있습니다(Johnson, 2010). 이러한 프라임 브로커 관계는 일반적으로 기관급 수수료를 생성하거나 수백만 달러의 계좌를 보유할 수 있는 경우에만 설정할 수 있습니다. 외환 프라임 브로커와 ECN의 경우 코로케이션 설정 요구 사항과 비용이 더 낮습니다. Currenex, EBS, FXall, Hotspot을 포함한 대부분의 외환 ECN은 Equinix의 NY4 시설과 같은 대형 상업 데이터 센터 내에서 운영되며, 해당 시설에 코로케이션하거나 그곳에 위치한 VPS에 가입하는 것은 그리 비싸지 않습니다.

일부 트레이더들은 원격 서버에 거래 프로그램을 코로케이션하면 지적 재산 도용에 노출될 수 있다는 우려를 표했습니다. 이 위험을 제거하는 가장 간단한 방법은 소스 코드가 아닌 "실행 파일(executables)"(인간에게는 의미 없이 보이는 이진 컴퓨터 코드)만 원격 서버에 저장하는 것입니다. (MATLAB 프로그램의 경우에도, 원격 서버에 로드하기 전에 모든 .m 파일을 .p 파일로 변환할 수 있습니다.) 소스 코드 없이는, 아무도 거래 프로그램의 운영 지침을 알 수 없으며, 아무도 거의 알지 못하는 블랙박스 전략에 자본을 투입하는 것을 어리석게 여길 것입니다. 정말로 편집증적인 사람을 위해, 프로그램을 시작하기 위해 현재 시간에 따라 변하는 비밀번호를 요구할 수도 있습니다.

사실상 모든 소프트웨어 프로그램은(VB 매크로로 실행되는 엑셀을 제외하고) 최신 시장 데이터와 주문 상태 업데이트를 수신한 후 10ms 미만에 새 주문을 제출하므로, 수천 개의 종목을 모니터링하기 위해 하나의 프로그램을 사용하지 않는 한 소프트웨어나 하드웨어 지연은 일반적으로 고빈도 거래의 병목이 아닙니다. (이 마지막 점에 대해서는 멀티스레딩 관련 문제에 대한 박스 1.3을 참조하세요.) 그러나 고빈도 전략을 백테스팅하는 것은 전혀 다른 문제입니다. 이를 위해서는 많은 달의 틱 데이터(거래와 시세), 아마도 많은 종목에 대해 백테스팅 플랫폼에 입력해야 합니다. 더 나쁜 것은, 때로는 레벨 2 시세도 입력해야 한다는 것입니다. 데이터의 양 자체가 특별한 방법으로 처리되지 않으면(예: 병렬 컴퓨팅 알고리즘 사용) 대부분의 기계의 메모리를 압도할 것입니다. 대부분의 특수 목적 백테스팅 플랫폼은 이 양의 데이터를 처리할 때 특별히 지능적으로 설계되지 않았으며, 대부분은 매수/매도/최종 틱 가격(및 거래량)이나 레벨 2 시세 모두의 데이터를 백테스트할 수 있는 장비를 갖추고 있지 않습니다. 따라서 고빈도 전략을 백테스팅하는 것은 보통 특수한 맞춤화를 가진 자체 독립 프로그램을 작성해야 합니다. 사실, 앞서 언급한 하이젠베르크 불확정성 원리 때문에 고빈도 전략을 백테스팅하는 것이 실제 수익성에 대해 많이 알려주지 않을 수 있습니다.

#### 멀티스레딩과 여러 종목의 고빈도 거래 (Multithreading and High-Frequency Trading of Multiple Symbols)

거래 플랫폼의 멀티스레딩은 여러 이벤트(보통 새로운 틱의 도착)에 동시에 응답할 수 있음을 의미합니다. 이는 프로그램이 여러 종목을 동시에 거래하는 경우 특히 중요하며, 이는 주식 거래 프로그램의 경우 흔합니다. 프로그램이 BBRY를 매도할지 결정하고 있다고 해서 AAPL에 대한 매수 주문이 지연되는 것을 원하지 않을 것입니다! Java나 Python과 같은 현대 프로그래밍 언어를 사용하여 자체 독립 거래 프로그램을 작성한다면, 이 능력이 이러한 언어에 기본이므로 멀티스레딩에 문제가 없을 것입니다. 그러나 MATLAB을 사용하는 경우, 병렬 컴퓨팅 도구 상자(Parallel Computing Toolbox)도 구매해야 합니다; 그렇지 않으면 멀티스레딩이 없습니다. (해당 도구 상자를 구매하더라도, 12개의 독립 스레드로 제한되며, 500개의 주식을 동시에 거래하기에는 거의 충분하지 않습니다!) 그러나 MATLAB의 멀티스레딩 부재를 "틱 손실"과 혼동하지 마세요. MATLAB에서 두 개의 다른 종목의 틱 데이터를 수신하기 위해 두 개의 "리스너(listener)" A와 B를 작성하면, 리스너 A가 틱 유발 이벤트를 처리하느라 바쁘다고 해서 리스너 B가 "청각 장애(deaf)"인 것은 아닙니다. 리스너 A가 처리를 마치면, 리스너 B는 A가 바쁜 동안 수신한 틱 이벤트를 처리하기 시작하며, 틱 손실은 없습니다(Kuznetsov, 2010).

고빈도 거래 외에도, 뉴스 구동 거래는 종종 최고급 특수 목적 플랫폼을 제외한 모든 것을 난관에 빠뜨립니다. 뉴스 구동 거래는 정의상 기계 판독 가능한 뉴스 피드를 입력으로 요구합니다. 대부분의 특수 목적 플랫폼은 이 기능을 갖추고 있지 않으며, 대부분의 오픈소스 IDE도 마찬가지입니다. 예외로 Progress Apama는 Dow Jones와 Reuters의 기계 판독 가능한 뉴스 피드를 통합하고, Deltix는 Ravenpack의 뉴스 감성 데이터 피드를 통합합니다. IDE 중에서는 Marketcetera가 benzinga.com의 뉴스 피드를 제공합니다(Bloomberg, Dow Jones, Reuters의 전달 속도에 맞추기는 어려울 것입니다). 자체 독립 거래 프로그램을 작성하는 경우, 뉴스 제공자의 API를 사용하여(예: Dow Jones와 Thomson Reuters 모두 API를 통해 기계 판독 가능한 뉴스를 제공) 또는 뉴스 제공자가 주기적으로 하드 드라이브에 FTP하는 뉴스 XML 파일을 단순히 읽어 이러한 뉴스 피드에 연결할 수 있는 유연성이 있습니다. 고빈도로 뉴스 거래를 하는 경우, 전자의 비싼 솔루션이 절대적으로 필요합니다. 그렇지 않으면, Newsware와 같은 업체에서 훨씬 더 저렴한 솔루션이 있습니다. 7장에서 이벤트 구동 거래에 대해 더 논의할 것입니다.

### 플랫폼에 복합 이벤트 처리가 있는가? (Does the Platform Have Complex Event Processing?)

*복합 이벤트 처리(Complex Event Processing, CEP)*는 프로그램이 이벤트에 즉각적으로 응답하고 적절한 조치를 취하는 것을 설명하는 유행하는 용어입니다. 우리가 관심 있는 이벤트는 보통 새로운 틱의 도착이나 뉴스 항목의 전달입니다. 알고리즘 트레이더에게 하나의 중요한 점은 프로그램이 이벤트 구동이지 봉 구동이 아니라는 것입니다. 즉, 프로그램이 각 봉의 끝에서 가격이나 뉴스 항목을 폴링하고 무엇을 할지 결정하지 않습니다. CEP가 이벤트 구동이므로, 이벤트 발생과 그에 대한 응답 사이에 지연이 없습니다.

즉시성이 CEP의 유일한 강점이라면, 거의 모든 브로커 API가 제공하는 이른바 콜백 함수(callback functions)를 사용할 수 있습니다. 콜백 함수도 새로운 틱이나 뉴스 항목이 도착할 때마다 유발되며, 이 새로운 데이터를 기반으로 모든 종류의 계산을 수행하고 주문을 제출할지 결정할 수 있습니다. 이는 규칙이 단순히 "지난 한 시간 동안의 가격 이동 평균"인 경우에는 쉽습니다.

그러나 규칙이 "지난 30분의 주문 흐름이 양수이고, 가격이 이동 평균 위에 있고, 변동성이 낮고, 중요한 뉴스 항목이 방금 도착했을 때 매도"와 같이 "복잡"하다면?

규칙이 이벤트 순서에 적용되는 during, between, afterwards, in parallel과 같은 많은 절을 포함한다면? CEP 지지자들에 따르면, 전통적인 프로그래밍 언어보다 CEP 언어를 사용하여 이러한 복잡한 규칙을 표현하는 것이 훨씬 더 간결합니다. 그러나 데이터 스누핑 편향을 피하기 위해 거래 규칙이 단순해야 한다는 주장은 어떨까요? 그들의 답변은 임의의 규칙을 찾기 위해 데이터를 마이닝하는 것이 아니라, 경험 많은 트레이더들이 이미 수익성이 있다고 아는 규칙을 단순히 구현하는 것이라고 합니다. 그들의 주장에 완전히 납득하지는 못하지만, 그렇다면 앞서 언급한 Progress Apama가 CEP 기술로 구별된다는 것을 알아야 합니다. 표 1.2에서 볼 수 있듯이 특정 무료 오픈소스 IDE에도 CEP가 있습니다.

#### 핵심 포인트 (KEY POINTS)

- 백테스팅은 전략의 미래 성과를 예측하지 못한다면 쓸모가 없지만, 백테스팅의 함정은 예측력을 감소시킵니다.
- 함정 제거:
  - 백테스팅과 실시간 실행 모두에 동일한 프로그램을 사용하는 플랫폼은 선행 편향을 제거할 수 있습니다.
  - 표본 외 테스트, 교차 검증, 높은 샤프 비율은 모두 데이터 스누핑 편향을 줄이기 위한 좋은 관행이지만, 워크포워드 테스트보다 더 결정적인 것은 없습니다.
  - 단순한 모델은 데이터 스누핑 편향에 대한 단순한 치료법입니다.
  - "왜 모델이 2012/7/9에 THQI에 대해 '숏' 신호를 생성했을까? 아, 1:10 역분할에 대해 과거 가격을 조정하는 것을 잊었기 때문이었습니다!"
  - "모델이 CMC 주식을 방금 매수했나요? 오늘이 배당 기준일인데 과거 가격을 조정하는 것을 잊지 않았는지 확인하셨나요?"
  - "모델이 롱 온리인 것을 봅니다. 데이터에 생존자 편향이 없는지 확인하셨나요?"
  - "종가를 사용한 평균 회귀 주식 거래 모델의 백테스트가 훌륭하지만, 1차 거래소 데이터로 다시 테스트하면 결과의 감소를 예상하세요."
  - "모델이 2008년 11월에 훌륭하게 수행되었습니다. 그런데 그때 많은 금융주를 공매도했나요? 그 주식들의 공매도가 금지되었다는 것을 잊지 마세요."
  - "이 고빈도 주식 거래 모델이 백테스트에서 좋아 보이지만, 숏 거래에 업틱 규칙을 적용했는지 궁금합니다."
  - "선물 캘린더 스프레드 모델이 스프레드를 형성하기 위해 가격 차이를 사용합니다. 왜 수익률 갭을 사용하여 가격을 역조정하고 있나요?"
  - "왜 평균 회귀 일중 선물 스프레드가 백테스트에서 잘 수행되었지만 실시간 거래에서는 저조했을까? 아, 백테스트에 봉 기반 데이터 대신 틱 기반 데이터를 사용했어야 했습니다."
  - "이 모멘텀 전략의 백테스트에 함정이 없어 보입니다. 그러나 2008년 이전에 잘 수행되었다고 해서 이후에도 잘 수행될 것이라는 의미는 아닙니다."
- 백테스트의 통계적 유의성:
  - "이 전략의 기대 APR이 10%이고 1% 이내로 통계적으로 유의하다는 것은 무엇을 의미하나요?" 답변: "과거 가격 시계열과 동일한 길이와 동일한 처음 세 모멘트를 가진 10,000개의 시뮬레이션된 가격 시계열에 전략을 실행하면, APR이 10% 이상인 표본 시계열이 100개뿐이라는 것을 의미합니다."
  - "이 전략의 기대 APR이 10%이고 1% 이내로 통계적으로 유의하다는 것은 무엇을 의미하나요?" 대안 답변: "거래의 진입 날짜를 무작위화하면, APR이 10% 이상인 무작위 순열이 100개 중 1개뿐이라는 것을 의미합니다."
- 어떤 백테스트 플랫폼을 선택할 것인가?
  - "저는 5천만 달러를 투자할 펀드를 시작하는 뛰어난 수학자인데, 프로그래밍을 모릅니다. 어떤 거래 플랫폼을 사용해야 할까요?" Deltix, QuantHouse, Progress Apama, 또는 RTD Tango와 같은 기관용 특수 목적 플랫폼을 선택하세요.
  - "저는 경험 많은 재량적 독립 트레이더이며, 전략을 자동화하고 싶습니다. 어떤 거래 플랫폼을 사용해야 할까요?" MetaTrader, NinjaTrader, Trading Blox, 또는 TradeStation과 같은 리테일 특수 목적 플랫폼을 선택하세요.
  - "저는 MATLAB을 사용한 전략 연구에 뛰어난 퀀트입니다. 이러한 전략을 어떻게 구현하고 '라이브'로 갈 수 있을까요?" Interactive Brokers를 위한 exchangeapi.com의 quant2ib API, Trading Technologies를 위한 quant2tt, 다른 브로커를 위한 www.pracplay.com, 또는 FIX 연결을 위한 MATFIX를 시도하세요.
  - "저는 훌륭한 C++, C#, Java 프로그래머이지만, 브로커와의 저수준 연결을 다루는 것이 싫고, 브로커를 바꿀 때마다 연결을 다시 작성하는 것이 싫습니다." Marketcetera, TradeLink, AlgoTrader, 또는 ActiveQuant와 같은 IDE 중 하나를 시도하세요.
- 실행 자동화:
  - "주문 확인 지연을 10ms 미만으로 줄이기 위해 데이터 센터에 거래 프로그램을 코로케이션하고 싶습니다." 브로커의 주문 확인 지연이 10ms보다 짧은지 확실합니까?
  - "Amazon의 EC2에 코로케이션되어 있습니다. 거래 프로그램에 공급되는 시장 데이터는 데스크톱 PC에서 받는 것보다 훨씬 더 최신이어야 합니다." 반드시 그렇지는 않습니다: EC2의 서버가 브로커의 데이터 서버에서 데스크톱 PC보다 (인터넷 거리로) 더 멀리 있을 수 있습니다.
  - "MATLAB의 병렬 컴퓨팅 도구 상자를 사용하고, GPU에서 프로그램을 실행합니다. 따라서 SPX의 500개 주식을 모두 동시에 거래할 수 있습니다." MATLAB의 병렬 컴퓨팅 도구 상자를 사용하더라도, 12개의 주식만 동시에 처리하는 것으로 제한됩니다. 자체 Java나 Python 프로그램을 작성하면 GPU에서 진정한 멀티스레딩이 가능합니다.
  - "제 IDE는 CEP가 활성화되어 있지 않습니다. 틱 기반 거래 전략을 정말 실행할 수 없습니다." CEP가 활성화되지 않은 플랫폼에도 틱에 의해 프로그램이 유발될 수 있는 콜백 함수가 있는 경우가 많습니다.
