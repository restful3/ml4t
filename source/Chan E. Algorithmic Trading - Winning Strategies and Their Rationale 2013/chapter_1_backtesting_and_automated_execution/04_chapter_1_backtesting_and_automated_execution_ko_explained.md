---
lang: ko
format:
  html:
    toc: true
    embed-resources: true
    theme: cosmo
---

# 제1장: 백테스팅과 자동화 실행 — 쉬운 해설판

> 이 글은 Ernest Chan의 "Algorithmic Trading" 제1장의 전체 내용을 빠짐없이 담되, 전문 용어와 개념을 일상적인 비유와 풀어쓴 설명으로 재구성한 해설판입니다.

---

## 들어가며 — 왜 백테스팅부터 시작할까?

여러분, 운전면허 시험을 치르기 전에 무엇을 하시나요? 당연히 모의 시험을 풀어봅니다. 주행 시뮬레이터에서 연습도 하죠. 실전 도로에 나가기 전에 "내가 정말 운전할 준비가 되었는지" 확인하는 과정입니다. 알고리즘 트레이딩에서 **백테스팅(backtesting)**이 바로 이 역할을 합니다. 과거 데이터를 이용해 "이 전략이 진짜 돈을 벌 수 있었을까?"를 시뮬레이션해 보는 **모의 시험**인 셈이죠.

이 책은 특정 범주의 전략, 특히 평균 회귀와 모멘텀 전략에 초점을 맞추고 있지만, 어떤 전략이든 공통적으로 적용되는 백테스팅의 중요한 원칙과 함정들이 있습니다. 이것들을 모르고 무작정 전략을 백테스트하면, 그 결과는 쓸모없을 뿐 아니라 **오히려 위험**할 수 있습니다. 마치 고장 난 내비게이션을 믿고 운전하다가 낭떠러지로 향하는 것과 같습니다. 잘못된 백테스트 결과를 믿고 실제 돈을 투자하면 상당한 재정적 손실을 입을 수 있기 때문입니다.

백테스팅은 보통 전략의 기대 수익률과 샤프 비율 같은 통계적 성과를 계산합니다. 그렇다면 자연스러운 질문이 나옵니다: "이 숫자들, 정말 믿을 만한 건가요?" 이를 확인하기 위해 **가설 검정(hypothesis testing)**과 **몬테카를로 시뮬레이션(Monte Carlo simulation)**이라는 도구를 사용합니다. 쉽게 말해, 가설 검정은 "이 성과가 우연인가, 아니면 진짜 실력인가?"를 판별하는 방법이고, 몬테카를로 시뮬레이션은 수천 번의 가상 시나리오를 돌려보며 확인하는 방법입니다.

일반적으로 백테스트에서 **왕복 거래(round trip trades)**가 많을수록 통계적 신뢰도가 높아집니다. 시험 문제를 10개 풀어보는 것과 1,000개 풀어보는 것 중 어느 쪽이 실력을 더 정확히 반영할까요? 당연히 후자입니다. 하지만 백테스트가 함정 없이 올바르게 수행되고 통계적으로 유의하다 해도, 반드시 미래를 예측할 수 있다는 보장은 없습니다. **체제 전환(regime shifts)** — 시장의 규칙 자체가 바뀌는 상황 — 이 모든 것을 무너뜨릴 수 있으며, 이 장에서 몇 가지 중요한 역사적 사례를 살펴볼 것입니다.

마지막으로, 소프트웨어 플랫폼의 선택도 중요합니다. 좋은 플랫폼은 생산성을 높이고, 다양한 자산 클래스에서 전략을 테스트할 수 있게 해주며, 함정에 빠질 가능성을 줄여줍니다. 특히 좋은 백테스팅 플랫폼과 좋은 **자동 실행(automated execution)** 플랫폼은 종종 하나로 결합됩니다. 백테스팅이 모의 시험이라면, 자동 실행은 **자동 조종 장치**와 같습니다. 비행기 조종사가 자동 조종 장치를 켜듯이, 전략이 검증되면 컴퓨터가 자동으로 주문을 실행하게 하는 것이죠.

---

## 1.1 백테스팅의 중요성 — 왜 꼭 직접 해봐야 할까?

### 백테스팅이란 무엇인가

**백테스팅(backtesting)**은 과거 데이터를 거래 전략에 입력하여 "만약 이 전략을 과거에 사용했다면 어떤 성과를 냈을까?"를 확인하는 과정입니다. 마치 지난 시즌 축구 경기 영상을 보면서 "만약 내가 이런 전술을 썼다면 이겼을까?"를 분석하는 것과 비슷합니다. 우리가 기대하는 것은, 과거 성과가 미래 성과를 어느 정도 예측해 줄 것이라는 점입니다.

### 직접 전략을 만든 경우

여러분이 직접 전략을 개발했다면, 백테스팅의 중요성은 두말할 필요가 없습니다. 자신이 만든 전략이 실제로 돈을 벌 수 있는지 확인하고 싶은 것은 당연합니다.

### 남이 만든 전략이라도 반드시 직접 테스트하라

하지만 논문이나 책에서 전략을 읽었고, 저자가 성과에 대해 거짓말을 하지 않았다고 신뢰하더라도, **독립적으로 백테스트하는 것은 여전히 필수**입니다. 왜 그럴까요? 여러 가지 이유가 있습니다.

**이유 1: 악마는 디테일에 있다**

전략의 수익성은 종종 구현의 세부 사항에 극도로 민감합니다. 예를 들어 생각해 보세요:

- 주식 주문을 **시장 개장 시 주문(market-on-open orders)**으로 보내야 할까요, 아니면 개장 직후 **시장가 주문(market orders)**으로 보내야 할까요?
- E-mini S&P 500 선물 주문을 오후 4시 주식 시장 마감 직전에 보내야 할까요, 아니면 오후 4시 15분 선물 시장 마감 직전에 보내야 할까요?
- 거래를 시작할 때 **매수호가(bid)**나 **매도호가(ask)**를 사용해야 할까요, 아니면 **최종 가격(last price)**을 사용해야 할까요?

이런 세부 사항들은 논문에서 종종 생략됩니다. 주요 아이디어에 집중하기 위해 의도적으로 빠뜨리는 경우도 많습니다. 하지만 이런 사소해 보이는 차이가 **실시간 거래의 수익성에 결정적 영향**을 미칠 수 있습니다. 이런 디테일을 확정하는 유일한 방법은 직접 백테스트하는 것입니다. 이상적으로는 백테스팅 프로그램을 **버튼 하나로 자동 실행 프로그램으로 전환**할 수 있어야 합니다. 모의 비행에서 실제 비행으로 자동 조종 장치를 전환하듯이요.

**이유 2: 함정을 직접 찾아낼 수 있다**

전략의 모든 세부 사항을 프로그램으로 구현하면, 이를 현미경 아래에 놓고 **숨어 있는 함정**을 찾을 수 있습니다:

- **롱(long)**과 **숏(short)** 포지션을 모두 가진 주식 포트폴리오 전략에서, 일부 주식이 **대차가 어렵고(hard to borrow)** 실제로는 공매도할 수 없다는 사실을 고려했나요?
- 선물 **페어 트레이딩(pair-trading)** 전략에서, 두 시장의 종가가 같은 시간에 발생하는지 확인했나요?

각 시장과 전략마다 고유한 함정이 있습니다. 그리고 일반적으로 이런 함정들은 백테스트 성과를 **실제보다 부풀리는 방향**으로 작용합니다. 이것이 특히 위험한 이유입니다. 과대평가된 성과를 믿고 돈을 투자하면 큰 손실을 볼 수 있으니까요.

**이유 3: 진정한 표본 외 테스트가 가능하다**

출판된 전략을 백테스팅하면 **출판 이후** 기간에 대해 진정한 **표본 외 테스트(out-of-sample testing)**를 수행할 수 있습니다. 이것이 왜 중요할까요?

많은 저자들이 "우리 모델은 표본 외 데이터로 검증되었다"고 주장합니다. 하지만 솔직히 말해서, 표본 외 결과가 나빴을 때 매개변수를 조금 바꾸거나 모델을 수정해서 "표본 외" 데이터에서도 좋아 보이게 만든 경우가 많습니다. 이것은 시험 답을 미리 보고 문제를 푸는 것과 다름없습니다! **진정한 표본 외 테스트는 전략이 출판되어 확정된 후에야 시작**될 수 있습니다. 논문이 2010년에 출판되었다면, 2011년 이후의 데이터가 진짜 표본 외 테스트인 셈이죠.

**이유 4: 전략을 개선할 수 있다**

직접 백테스팅하면 전략을 **더 수익성 있게 또는 덜 위험하게** 만드는 방법을 찾을 수 있습니다. 이 과정은 **과학적 방법(scientific method)**을 따라야 합니다:

1. 시장에 대한 직관이나 연구에 기반한 **가설**을 세운다 (예: "이 종목 쌍에 차익거래 기회가 있다")
2. 백테스트를 통해 이 가설을 **확인하거나 반박**한다
3. 결과가 충분히 좋지 않으면 가설을 **수정**하고 과정을 반복한다

세부 사항의 작은 변화가 큰 개선을 가져올 수 있습니다. **이동 평균의 회고 기간(look-back period)**을 바꾸거나, 종가 대신 시가에 주문을 넣는 것만으로도 상당한 차이가 날 수 있습니다. 요리 레시피를 따르되 소금 양을 조금 조절하면 맛이 확 달라지는 것처럼요.

---

## 1.2 백테스팅의 일반적인 함정 — 지뢰밭을 안전하게 통과하기

거의 모든 전략에는 백테스팅에서 실수할 수 있는 고유한 기회가 있습니다. 하지만 여러 시장에 공통적으로 적용되는 함정들이 있으며, 이것들을 하나씩 살펴보겠습니다. 이 함정들은 마치 지뢰밭의 지뢰와 같습니다. 어디에 있는지 알면 피할 수 있지만, 모르면 밟게 됩니다.

### 1.2.1 선행 편향 — 미래에서 온 정보를 훔치지 마라

**선행 편향(look-ahead bias)**은 이름 그대로, 백테스트 프로그램이 **미래 정보를 몰래 사용**하는 것입니다. 오늘의 거래 결정을 내리는 데 내일의 가격을 사용하거나, 더 일반적으로 현재 시점에서 "예측"을 하기 위해 아직 알 수 없는 미래 정보를 사용하는 것이죠.

비유하자면, 시험을 치르면서 답안지를 슬쩍 보는 것과 같습니다. 답안지를 보면 당연히 점수가 좋겠지만, 그건 진짜 실력이 아닙니다!

가장 흔한 예는 당일의 **고가(high)**나 **저가(low)**를 사용하여 당일 진입 신호를 결정하는 것입니다. 거래일이 끝나기 전에는 그날의 고가와 저가를 알 수 없습니다. 오전 10시에 "오늘 최저가에 사라"는 신호를 만드려면, 오늘 하루가 끝나야 최저가를 알 수 있잖아요. 이것은 시간 여행이 필요한 전략입니다!

선행 편향은 본질적으로 **프로그래밍 오류**입니다. 실시간 거래 프로그램에서는 미래 정보를 얻을 방법이 없으므로 절대 발생하지 않습니다. 이 차이가 선행 편향을 피하는 명확한 방법을 알려줍니다: **백테스팅과 실시간 거래 프로그램이 동일하다면, 선행 편향이 있을 수 없습니다.** 두 프로그램의 유일한 차이가 입력 데이터(과거 데이터 vs. 실시간 시장 데이터)뿐이라면, 미래 정보가 끼어들 여지가 없습니다. 이 장의 뒷부분에서 이런 통합 플랫폼을 살펴보겠습니다.

### 1.2.2 데이터 스누핑 편향과 선형성의 아름다움 — 단순함이 최고의 무기

#### 데이터 스누핑 편향이란?

**데이터 스누핑 편향(data-snooping bias)**은 과거 데이터에서 우연히 나타난 일시적 패턴에 모델을 **과도하게 맞추는** 것입니다. 너무 많은 **자유 매개변수(free parameters)**로 모델을 튜닝하면, 과거에는 완벽해 보이지만 미래에는 작동하지 않는 전략이 됩니다.

비유하자면, 지난 기말고사 문제의 정답을 달달 외우는 것과 같습니다. 과거 시험은 만점을 받겠지만, 새로운 시험 문제가 나오면 속수무책이죠. 이것이 바로 **과적합(overfitting)**의 위험입니다.

#### 어떻게 방지할까?

감지 방법은 잘 알려져 있습니다: **표본 외 데이터(out-of-sample data)**에서 모델을 테스트하고, 통과하지 못하면 모델을 버려야 합니다. 하지만 말처럼 쉬운 일이 아닙니다. 수주간 공들인 모델을 완전히 버릴 의지가 정말 있으신가요? 우리 대부분은 모델을 이리저리 수정해서 표본 내(in-sample)와 표본 외 모두에서 합리적으로 작동하게 만들 것입니다. 하지만 이렇게 하면 **표본 외 데이터를 사실상 표본 내 데이터로 전환**해 버린 셈입니다!

고정된 표본 외 데이터만으로 모델을 판단하고 싶지 않다면(그 데이터에서의 저조한 성과가 단지 운이 나빠서일 수도 있으니까), 또는 애초에 데이터가 부족하다면, **교차 검증(cross-validation)**을 고려해야 합니다. 데이터의 여러 부분 집합을 돌아가며 훈련/테스트하고, 모델이 이 다양한 부분 집합에서 일관되게 잘 수행되는지 확인하는 것입니다. 높은 **샤프 비율(Sharpe ratio)**과 짧은 **최대 손실 기간(maximum drawdown duration)**을 가진 모델은 거의 자동으로 교차 검증을 통과합니다. 손실 기간이 짧다는 것은 어떤 구간을 뽑아도 대부분 수익이 난다는 뜻이니까요.

#### 단순함의 힘 — 선형 모델의 우월성

데이터 스누핑 편향을 최소화하는 가장 좋은 접근법은 **가능한 한 적은 매개변수로, 가능한 한 단순한 모델**을 만드는 것입니다.

여기서 중요한 통찰이 있습니다: 매개변수가 적더라도 **복잡한 거래 규칙이 많은 모델**도 데이터 스누핑에 마찬가지로 취약합니다. 두 원칙 모두 하나의 결론으로 수렴합니다: **비선형 모델(nonlinear models)보다 선형 모델(linear models)이 더 안전하다.** 비선형 모델은 더 복잡하고 일반적으로 더 많은 자유 매개변수를 가지기 때문입니다.

과거 가격으로 미래 가격을 예측하려 한다고 합시다. 비선형 모델은 과거 데이터에 확실히 더 잘 맞겠지만(구불구불한 곡선이 직선보다 데이터 포인트를 더 많이 지나갈 수 있으니까), 미래를 더 잘 예측한다는 보장은 없습니다. 미적분학의 **테일러 급수 전개(Taylor-series expansion)**를 떠올려 보세요. 모든 비선형 모델은 선형 모델로 근사할 수 있습니다. 즉, 대부분의 비선형 모델에는 대응하는 더 단순한 선형 근사가 존재하며, 선형 모델을 사용하지 않는 데는 **타당한 이유가 있어야** 합니다. (저차항이 사라지는 예외적 경우를 제외하면, 이런 경우는 현실 금융 시계열에서 거의 나타나지 않습니다.)

확률 분포의 선택에서도 같은 논리가 적용됩니다. **가우시안 분포(Gaussian distribution)**가 극단적 사건을 포착하지 못한다는 비판을 자주 듣습니다. 맞는 말입니다. 하지만 대안은요? 왜도(skew)와 첨도(kurtosis)를 포착할 수 있는 **스튜던트 *t*-분포**? 유한한 2차 모멘트를 완전히 없애는 **파레토 분포(Pareto distribution)**? 어떤 것을 선택하든 자의적인 면이 있고, 유한한 데이터로 결정해야 합니다. **오컴의 면도날(Occam's razor)** — "불필요한 복잡성을 추가하지 마라" — 은 비가우시안 분포를 지지하는 강력한 이론적/경험적 이유가 없는 한 가우시안 형태를 가정하라고 말합니다.

#### 선형 모델의 실전 적용

선형 모델은 가격 예측뿐 아니라 **자본 배분**에서도 선형성을 의미합니다. 예를 들어, 가격이 평균으로 돌아오는 **평균 회귀(mean-reverting)** 모델을 생각해 봅시다. 다음 시간 $dt$ 동안의 가격 변화 $dy$가 평균 가격과 현재 가격의 차이에 비례한다고 가정합니다:

$$dy(t) = (\lambda y(t - 1) + \mu)dt + d\epsilon$$

이것이 이른바 **"오른스타인-울렌벡(Ornstein-Uhlenbeck)"** 공식으로, 2장에서 더 자세히 설명합니다. 각 변수를 살펴보면:

- $dy(t)$: 시간 $t$에서의 가격 변화량
- $\lambda$: 평균으로 되돌아오는 속도를 나타내는 계수 (음수값)
- $y(t-1)$: 이전 시점의 가격
- $\mu$: 장기 평균에 관련된 상수
- $dt$: 미소 시간 간격
- $d\epsilon$: 랜덤 노이즈 (예측 불가능한 변동)

많은 트레이더들이 **볼린저 밴드(Bollinger band)** 모델을 사용하여 가격이 특정 임계값을 초과하면 매도하고, 미달하면 매수합니다. 하지만 선형 모델을 고수한다면, 모든 가격 움직임마다 점진적으로 매수 또는 매도해야 합니다. 총 시장 가치는 평균으로부터의 편차에 비례하게 됩니다. 트레이더 용어로 이것을 **"평균 매수(averaging-in)"** 또는 **"분할 매수(scaling-in)"**라 하며, 3장에서 더 자세히 다룹니다.

이 책에서 선형 거래 모델의 여러 예를 찾을 수 있습니다. 이 기법의 단순성은 수익이 전략의 미묘하고 복잡한 영리함에서 나오는 것이 아니라 평범하게 보이는 곳에 숨겨진 **시장의 본질적인 비효율성**에서 나온다는 점을 설명할 수 있게 합니다. 조급한 독자는 예제 4.2를 미리 볼 수 있는데, 이는 상장지수펀드(ETF)와 그 구성 종목 간의 선형 평균 회귀 전략을 보여주며, 예제 4.3과 4.4는 주식에 대한 두 가지 선형 롱-숏 통계적 차익거래(statistical arbitrage) 전략을 보여줍니다.

#### 가장 극단적인 선형 모델: 동일 가중치

선형 예측 모델의 가장 극단적인 형태는 **모든 계수의 크기가 같은** 것입니다(반드시 부호가 같을 필요는 없습니다). 예를 들어, 주식 수익률 예측에 여러 요인(*f*)을 사용한다고 합시다. 한 요인은 오늘의 수익률이고(양의 오늘 수익률이 양의 미래 수익률을 예측), 다른 요인은 변동성 지수(VIX) 변화일 수 있습니다(음의 변화가 양의 미래 수익률을 예측). 이 요인들을 먼저 **Z-점수(Z-scores)**로 정규화합니다:

$$z(i) = \frac{f(i) - \text{mean}(f)}{\text{std}(f)} \qquad (1.1)$$

이 수식이 하는 일을 풀어보면:

- $f(i)$: $i$번째 요인의 현재 값
- $\text{mean}(f)$: 이 요인의 과거 평균
- $\text{std}(f)$: 이 요인의 과거 표준편차
- $z(i)$: 정규화된 점수 — "평균에서 표준편차 몇 개만큼 떨어져 있는가"를 나타냄

왜 정규화할까요? 서로 다른 요인들의 단위와 크기가 다르기 때문입니다. 키(cm)와 체중(kg)을 비교하려면 같은 척도로 맞춰야 하듯이요.

그런 다음 내일의 수익률 *R*을 다음과 같이 예측합니다:

$$R = \text{mean}(R) + \text{std}(R) \frac{\sum_{i=1}^{n} \text{sign}(i)z(i)}{n} \qquad (1.2)$$

각 변수의 의미:

- $\text{mean}(R)$: 1일 수익률의 과거 평균
- $\text{std}(R)$: 1일 수익률의 과거 표준편차
- $\text{sign}(i)$: $f(i)$와 수익률 $R$ 사이의 과거 상관관계의 부호 (+1 또는 -1)
- $n$: 사용하는 요인의 총 개수
- $z(i)$: 식 1.1에서 계산한 정규화된 요인 값

노벨 경제학상 수상자 **다니엘 카너먼(Daniel Kahneman)**은 그의 베스트셀러 *생각에 관한 생각(Thinking, Fast and Slow)*에서 "**모든 예측 변수에 동일한 가중치를 할당하는 공식은 표본 추출의 우연에 영향을 받지 않기 때문에 종종 우수하다**"(Kahneman, 2011)고 했습니다. 식 1.2는 주식 수익률 예측에 사용되는 일반적인 요인 모델의 단순화된 버전입니다. 절대 수익률 예측은 정확하지 않을 수 있지만, 주식 간의 **상대 수익률** 예측은 종종 충분히 좋습니다. 상위 십분위수 주식을 매수하고 하위 십분위수를 공매도하면, 평균 수익률이 양수인 경우가 많습니다.

#### 순위 기반 접근법

목표가 기대 수익률이 아니라 **주식의 순위**를 매기는 것이라면, 식 1.1과 1.2를 사용하지 않고 더 간단한 방법이 있습니다. 요인 $f(i)$에 기반하여 주식 $s$의 순위를 계산하고, 상관관계 부호를 곱한 뒤, 모두 합산합니다:

$$\text{rank}_s = \sum_{i=1}^{n} \text{sign}(i) \text{rank}_s(i) \qquad (1.3)$$

이 수식이 하는 일:

- $\text{rank}_s(i)$: $i$번째 요인에 따른 주식 $s$의 순위 (예: 100개 주식 중 몇 번째인지)
- $\text{sign}(i)$: 해당 요인과 수익률 사이의 상관관계 부호
- $\text{rank}_s$: 최종 종합 순위

**조엘 그린블라트(Joel Greenblatt)**가 유명한 두 요인 **"마법 공식(magic formula)"**으로 이 방법을 사용했습니다: $f(1)$ = **투하자본수익률(return on capital)**, $f(2)$ = **이익 수익률(earnings yield)** (Greenblatt, 2006). 상위 30개 주식을 매수하고 1년간 보유하면, 1988~2004년 **연간 수익률(APR)이 30.8%**로, S&P 500의 12.4%를 크게 앞섰습니다. 선형성의 놀라운 승리입니다!

#### 워크포워드 테스트: 궁극의 검증

아무리 조심해도 데이터 스누핑 편향은 어떻게든 스며들 수 있습니다. 따라서 최종적이고 진정한 표본 외 테스트로서 **워크포워드 테스트(walk-forward test)**를 수행해야 합니다. 이 테스트는 모의 거래(paper trading) 형태로 할 수 있지만, 이상적으로는 **실제 자금**(최소한의 레버리지)으로 거래해야 합니다. 모의 거래에서는 드러나지 않는 실행 문제를 확인할 수 있기 때문입니다. 대부분의 트레이더들은 실시간 거래가 **백테스트 샤프 비율의 절반**보다 나은 결과를 보이면 만족할 것입니다.

### 1.2.3 주식 분할과 배당 조정 — 가격 데이터의 덫

#### 주식 분할이 백테스트를 어떻게 속이나

회사의 주식이 $N$ 대 1 분할을 하면, 주가는 $N$배로 나뉩니다. 하지만 분할 전에 100주를 갖고 있었다면 분할 후에는 $N \times 100$주가 되므로, **총 시장 가치는 변하지 않습니다**. 주식 분할은 피자를 8조각으로 자르든 16조각으로 자르든 피자의 총 크기는 같은 것과 마찬가지입니다.

문제는 백테스트에서 보통 **가격 시계열**만 보고 거래 신호를 결정한다는 점입니다. 분할 기준일(ex-date) 이전의 가격을 $N$으로 나눠 역조정하지 않으면, 기준일에 **가격이 갑자기 급락한 것처럼** 보입니다. 이것이 잘못된 거래 신호를 유발할 수 있습니다. 이 조정은 백테스팅뿐 아니라 **실시간 거래에서도** 필요합니다 — 기준일에 시장이 열리기 직전에 과거 가격을 $N$으로 나눠야 합니다. (1 대 $N$ 역분할의 경우에는 기준일 이전 가격에 $N$을 곱해야 합니다.)

#### 배당도 같은 문제를 일으킨다

마찬가지로, 회사가 주당 *d*의 현금(또는 주식) 배당을 지급하면, 주가도 *d*만큼 하락합니다(다른 시장 움직임이 없는 경우). 배당을 받으므로 총 가치는 변하지 않지만, 가격 시계열만 보면 급락으로 보입니다. 기준일 이전의 가격을 역조정하지 않으면 잘못된 거래 신호가 발생합니다. 이 조정 역시 기준일에 시장이 열리기 직전에 실시간 거래 모델에 사용되는 모든 과거 데이터에 적용되어야 합니다. (이 논의는 ETF에도 동일하게 적용됩니다. 옵션 가격에는 약간 더 복잡한 처리가 필요합니다.)

과거 분할 및 배당 정보는 earnings.com에서 무료로 확인할 수 있으며(미래 예정 분할/배당 정보도 포함), 이미 조정된 과거 데이터는 csidata.com에서 쉽게 다운로드할 수 있습니다.

### 1.2.4 주식 데이터베이스의 생존자 편향 — 죽은 주식이 빠진 명단의 위험

**생존자 편향(survivorship bias)**은 과거 데이터에 **상장 폐지된 주식이 포함되어 있지 않을 때** 발생합니다. 이것은 "졸업생 중 성공한 사람만 인터뷰하고, 그 학교의 교육이 훌륭하다고 결론 내리는 것"과 같습니다. 실패한 졸업생(=상장 폐지된 주식)을 무시하면 전체 그림이 왜곡됩니다.

극단적인 예를 들어봅시다. 모델이 "전일 가장 많이 하락한 주식을 매수하고 영원히 보유"하라고 한다면? 실제로 이 전략은 거의 확실히 실패합니다. 크게 하락한 주식의 회사가 파산으로 이어져 100% 손실을 초래하는 경우가 많기 때문입니다. 하지만 데이터에 오늘까지 **살아남은 주식만** 포함되어 있다면, 백테스트 결과는 환상적으로 보일 수 있습니다. 크게 하락했지만 결국 살아남은 "운 좋은" 주식만 선택하게 되니까요. 하지만 전략을 실시간으로 거래했다면 어떤 주식이 최종적으로 살아남을지 예측할 수 없었을 것입니다.

생존자 편향의 영향은 전략 유형에 따라 다릅니다:

- **평균 회귀 롱 온리(long-only) 전략**: 가장 위험합니다. 하락한 주식을 사서 회복을 기대하는 전략인데, 파산한 주식은 데이터에 없으므로 성과가 부풀려집니다.
- **숏 온리(short-only) 전략**: 반대 효과입니다. 가격이 0으로 간 주식(숏에서 큰 수익)이 데이터에 없으므로 성과가 오히려 과소평가됩니다.
- **롱-숏(long-short) 전략**: 두 효과가 상쇄되지만, 롱 쪽 부풀림이 숏 쪽 감소보다 큰 경향이 있어 위험이 줄지만 완전히 제거되지는 않습니다.
- **모멘텀(momentum) 전략**: 상대적으로 덜 위험합니다. 수익성 있는 숏 모멘텀 거래가 생존자 편향 데이터에서 생략되므로, 백테스트 수익률이 오히려 감소합니다.

생존자 편향이 없는 데이터는 csidata.com(상장 폐지된 주식 목록 제공), kibot.com, tickdata.com, crsp.com에서 구매할 수 있습니다. 또는 매일 인덱스의 모든 주식 가격을 저장하여 직접 수집할 수도 있습니다. 이런 데이터가 없다면, 최근 3년 정도의 데이터로 백테스팅을 제한하여 피해를 줄일 수 있습니다.
