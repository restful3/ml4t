---
lang: ko
format:
  html:
    toc: true
    embed-resources: true
    theme: cosmo
---

# 제1장: 백테스팅과 자동화 실행 — 쉬운 해설판

> 이 글은 Ernest Chan의 "Algorithmic Trading" 제1장의 전체 내용을 빠짐없이 담되, 전문 용어와 개념을 일상적인 비유와 풀어쓴 설명으로 재구성한 해설판입니다.

---

## 들어가며 — 왜 백테스팅부터 시작할까?

여러분, 운전면허 시험을 치르기 전에 무엇을 하시나요? 당연히 모의 시험을 풀어봅니다. 주행 시뮬레이터에서 연습도 하죠. 실전 도로에 나가기 전에 "내가 정말 운전할 준비가 되었는지" 확인하는 과정입니다. 알고리즘 트레이딩에서 **백테스팅(backtesting)**이 바로 이 역할을 합니다. 과거 데이터를 이용해 "이 전략이 진짜 돈을 벌 수 있었을까?"를 시뮬레이션해 보는 **모의 시험**인 셈이죠.

이 책은 특정 범주의 전략, 특히 평균 회귀와 모멘텀 전략에 초점을 맞추고 있지만, 어떤 전략이든 공통적으로 적용되는 백테스팅의 중요한 원칙과 함정들이 있습니다. 이것들을 모르고 무작정 전략을 백테스트하면, 그 결과는 쓸모없을 뿐 아니라 **오히려 위험**할 수 있습니다. 마치 고장 난 내비게이션을 믿고 운전하다가 낭떠러지로 향하는 것과 같습니다. 잘못된 백테스트 결과를 믿고 실제 돈을 투자하면 상당한 재정적 손실을 입을 수 있기 때문입니다.

백테스팅은 보통 전략의 기대 수익률과 샤프 비율 같은 통계적 성과를 계산합니다. 그렇다면 자연스러운 질문이 나옵니다: "이 숫자들, 정말 믿을 만한 건가요?" 이를 확인하기 위해 **가설 검정(hypothesis testing)**과 **몬테카를로 시뮬레이션(Monte Carlo simulation)**이라는 도구를 사용합니다. 쉽게 말해, 가설 검정은 "이 성과가 우연인가, 아니면 진짜 실력인가?"를 판별하는 방법이고, 몬테카를로 시뮬레이션은 수천 번의 가상 시나리오를 돌려보며 확인하는 방법입니다.

일반적으로 백테스트에서 **왕복 거래(round trip trades)**가 많을수록 통계적 신뢰도가 높아집니다. 시험 문제를 10개 풀어보는 것과 1,000개 풀어보는 것 중 어느 쪽이 실력을 더 정확히 반영할까요? 당연히 후자입니다. 하지만 백테스트가 함정 없이 올바르게 수행되고 통계적으로 유의하다 해도, 반드시 미래를 예측할 수 있다는 보장은 없습니다. **체제 전환(regime shifts)** — 시장의 규칙 자체가 바뀌는 상황 — 이 모든 것을 무너뜨릴 수 있으며, 이 장에서 몇 가지 중요한 역사적 사례를 살펴볼 것입니다.

마지막으로, 소프트웨어 플랫폼의 선택도 중요합니다. 좋은 플랫폼은 생산성을 높이고, 다양한 자산 클래스에서 전략을 테스트할 수 있게 해주며, 함정에 빠질 가능성을 줄여줍니다. 특히 좋은 백테스팅 플랫폼과 좋은 **자동 실행(automated execution)** 플랫폼은 종종 하나로 결합됩니다. 백테스팅이 모의 시험이라면, 자동 실행은 **자동 조종 장치**와 같습니다. 비행기 조종사가 자동 조종 장치를 켜듯이, 전략이 검증되면 컴퓨터가 자동으로 주문을 실행하게 하는 것이죠.

---

## 1.1 백테스팅의 중요성 — 왜 꼭 직접 해봐야 할까?

### 백테스팅이란 무엇인가

**백테스팅(backtesting)**은 과거 데이터를 거래 전략에 입력하여 "만약 이 전략을 과거에 사용했다면 어떤 성과를 냈을까?"를 확인하는 과정입니다. 마치 지난 시즌 축구 경기 영상을 보면서 "만약 내가 이런 전술을 썼다면 이겼을까?"를 분석하는 것과 비슷합니다. 우리가 기대하는 것은, 과거 성과가 미래 성과를 어느 정도 예측해 줄 것이라는 점입니다.

좀 더 구체적으로 말하자면, 백테스팅은 이렇게 작동합니다. 여러분이 "20일 이동평균이 50일 이동평균을 상향 돌파하면 매수하고, 하향 돌파하면 매도한다"는 전략을 떠올렸다고 합시다. 이 아이디어가 실제로 수익을 낼 수 있는지 어떻게 알 수 있을까요? 2010년부터 2023년까지의 과거 주가 데이터를 가져와서, 이 규칙대로 매일 거래 신호를 만들고, 가상으로 매수와 매도를 실행해 봅니다. 13년간의 시뮬레이션이 끝나면 "연 평균 수익률이 12%이고, 최대 손실이 15%였다"는 식의 성과표가 나옵니다. 이것이 백테스팅의 결과물입니다.

### 직접 전략을 만든 경우

여러분이 직접 전략을 개발했다면, 백테스팅의 중요성은 두말할 필요가 없습니다. 자신이 만든 전략이 실제로 돈을 벌 수 있는지 확인하고 싶은 것은 당연합니다. 아무리 논리적으로 완벽해 보이는 전략이라도, 과거 데이터에 적용해 보면 예상과 전혀 다른 결과가 나오는 경우가 허다합니다. "이론상으로는 완벽한데 실전에서는 망한다"는 것을 사전에 발견할 수 있는 유일한 방법이 바로 백테스팅입니다.

### 남이 만든 전략이라도 반드시 직접 테스트하라

하지만 논문이나 책에서 전략을 읽었고, 저자가 성과에 대해 거짓말을 하지 않았다고 신뢰하더라도, **독립적으로 백테스트하는 것은 여전히 필수**입니다. 왜 그럴까요? 여러 가지 이유가 있습니다.

**이유 1: 악마는 디테일에 있다**

전략의 수익성은 종종 구현의 세부 사항에 극도로 민감합니다. 예를 들어 생각해 보세요:

- 주식 주문을 **시장 개장 시 주문(market-on-open orders)**으로 보내야 할까요, 아니면 개장 직후 **시장가 주문(market orders)**으로 보내야 할까요?
- E-mini S&P 500 선물 주문을 오후 4시 주식 시장 마감 직전에 보내야 할까요, 아니면 오후 4시 15분 선물 시장 마감 직전에 보내야 할까요?
- 거래를 시작할 때 **매수호가(bid)**나 **매도호가(ask)**를 사용해야 할까요, 아니면 **최종 가격(last price)**을 사용해야 할까요?

이런 세부 사항들은 논문에서 종종 생략됩니다. 주요 아이디어에 집중하기 위해 의도적으로 빠뜨리는 경우도 많습니다. 하지만 이런 사소해 보이는 차이가 **실시간 거래의 수익성에 결정적 영향**을 미칠 수 있습니다. 이런 디테일을 확정하는 유일한 방법은 직접 백테스트하는 것입니다. 이상적으로는 백테스팅 프로그램을 **버튼 하나로 자동 실행 프로그램으로 전환**할 수 있어야 합니다. 모의 비행에서 실제 비행으로 자동 조종 장치를 전환하듯이요.

**이유 2: 함정을 직접 찾아낼 수 있다**

전략의 모든 세부 사항을 프로그램으로 구현하면, 이를 현미경 아래에 놓고 **숨어 있는 함정**을 찾을 수 있습니다:

- **롱(long)**과 **숏(short)** 포지션을 모두 가진 주식 포트폴리오 전략에서, 일부 주식이 **대차가 어렵고(hard to borrow)** 실제로는 공매도할 수 없다는 사실을 고려했나요?
- 선물 **페어 트레이딩(pair-trading)** 전략에서, 두 시장의 종가가 같은 시간에 발생하는지 확인했나요?

각 시장과 전략마다 고유한 함정이 있습니다. 그리고 일반적으로 이런 함정들은 백테스트 성과를 **실제보다 부풀리는 방향**으로 작용합니다. 이것이 특히 위험한 이유입니다. 과대평가된 성과를 믿고 돈을 투자하면 큰 손실을 볼 수 있으니까요.

**이유 3: 진정한 표본 외 테스트가 가능하다**

출판된 전략을 백테스팅하면 **출판 이후** 기간에 대해 진정한 **표본 외 테스트(out-of-sample testing)**를 수행할 수 있습니다. 이것이 왜 중요할까요?

많은 저자들이 "우리 모델은 표본 외 데이터로 검증되었다"고 주장합니다. 하지만 솔직히 말해서, 표본 외 결과가 나빴을 때 매개변수를 조금 바꾸거나 모델을 수정해서 "표본 외" 데이터에서도 좋아 보이게 만든 경우가 많습니다. 이것은 시험 답을 미리 보고 문제를 푸는 것과 다름없습니다! **진정한 표본 외 테스트는 전략이 출판되어 확정된 후에야 시작**될 수 있습니다. 논문이 2010년에 출판되었다면, 2011년 이후의 데이터가 진짜 표본 외 테스트인 셈이죠.

**이유 4: 전략을 개선할 수 있다**

직접 백테스팅하면 전략을 **더 수익성 있게 또는 덜 위험하게** 만드는 방법을 찾을 수 있습니다. 이 과정은 **과학적 방법(scientific method)**을 따라야 합니다:

1. 시장에 대한 직관이나 연구에 기반한 **가설**을 세운다 (예: "이 종목 쌍에 차익거래 기회가 있다")
2. 백테스트를 통해 이 가설을 **확인하거나 반박**한다
3. 결과가 충분히 좋지 않으면 가설을 **수정**하고 과정을 반복한다

세부 사항의 작은 변화가 큰 개선을 가져올 수 있습니다. **이동 평균의 회고 기간(look-back period)**을 바꾸거나, 종가 대신 시가에 주문을 넣는 것만으로도 상당한 차이가 날 수 있습니다. 요리 레시피를 따르되 소금 양을 조금 조절하면 맛이 확 달라지는 것처럼요.

---

## 1.2 백테스팅의 일반적인 함정 — 지뢰밭을 안전하게 통과하기

이 섹션은 이 장에서 가장 실용적이고 중요한 부분입니다. 여러분이 실제로 백테스팅을 할 때 가장 자주 빠지는 함정들을 하나하나 해부합니다.

거의 모든 전략에는 백테스팅에서 실수할 수 있는 고유한 기회가 있습니다. 일부는 모든 시장에 일반적으로 적용되고, 다른 일부는 특정 시장에 관련됩니다. 이것들을 하나씩 살펴보겠습니다. 이 함정들은 마치 지뢰밭의 지뢰와 같습니다. 어디에 있는지 알면 피할 수 있지만, 모르면 밟게 됩니다. 그리고 여기서 중요한 점: 대부분의 함정은 백테스트 성과를 **실제보다 좋게** 보이게 만드는 방향으로 작용합니다. 이것이 특히 위험합니다. 함정이 성과를 나쁘게 만든다면 단순히 좋은 전략을 놓치는 것에 불과하지만, 성과를 부풀린다면 나쁜 전략에 실제 돈을 투자하게 만들 수 있기 때문입니다.

### 1.2.1 선행 편향 — 미래에서 온 정보를 훔치지 마라

**선행 편향(look-ahead bias)**은 이름 그대로, 백테스트 프로그램이 **미래 정보를 몰래 사용**하는 것입니다. 오늘의 거래 결정을 내리는 데 내일의 가격을 사용하거나, 더 일반적으로 현재 시점에서 "예측"을 하기 위해 아직 알 수 없는 미래 정보를 사용하는 것이죠.

비유하자면, 시험을 치르면서 답안지를 슬쩍 보는 것과 같습니다. 답안지를 보면 당연히 점수가 좋겠지만, 그건 진짜 실력이 아닙니다!

가장 흔한 예는 당일의 **고가(high)**나 **저가(low)**를 사용하여 당일 진입 신호를 결정하는 것입니다. 거래일이 끝나기 전에는 그날의 고가와 저가를 알 수 없습니다. 오전 10시에 "오늘 최저가에 사라"는 신호를 만드려면, 오늘 하루가 끝나야 최저가를 알 수 있잖아요. 이것은 시간 여행이 필요한 전략입니다!

선행 편향은 본질적으로 **프로그래밍 오류**입니다. 실시간 거래 프로그램에서는 미래 정보를 얻을 방법이 없으므로 절대 발생하지 않습니다. 이 차이가 선행 편향을 피하는 명확한 방법을 알려줍니다: **백테스팅과 실시간 거래 프로그램이 동일하다면, 선행 편향이 있을 수 없습니다.** 두 프로그램의 유일한 차이가 입력 데이터(과거 데이터 vs. 실시간 시장 데이터)뿐이라면, 미래 정보가 끼어들 여지가 없습니다. 이 장의 뒷부분에서 이런 통합 플랫폼을 살펴보겠습니다.

### 1.2.2 데이터 스누핑 편향과 선형성의 아름다움 — 단순함이 최고의 무기

#### 데이터 스누핑 편향이란?

**데이터 스누핑 편향(data-snooping bias)**은 과거 데이터에서 우연히 나타난 일시적이고 무작위적인 시장 패턴에 모델을 **과도하게 맞추는** 것입니다. 너무 많은 **자유 매개변수(free parameters)**로 모델을 튜닝하면, 과거에는 완벽해 보이지만 미래에는 작동하지 않는 전략이 됩니다. 이러한 무작위 시장 패턴은 미래에 재발할 가능성이 낮으므로, 이런 패턴에 맞춰진 모델은 예측력이 거의 없습니다.

비유하자면, 지난 기말고사 문제의 정답을 달달 외우는 것과 같습니다. 과거 시험은 만점을 받겠지만, 새로운 시험 문제가 나오면 속수무책이죠. 이것이 바로 **과적합(overfitting)**의 위험입니다. 또 다른 비유를 들어보겠습니다. 구름의 모양에서 동물 형상을 찾는 것과 같습니다. "저 구름이 토끼 모양이다!"라고 할 수 있지만, 그 구름이 토끼 모양인 것은 순전히 우연이며, 다음에 비슷한 구름이 다시 나타날 가능성은 거의 없습니다. 데이터 스누핑은 과거 가격 데이터의 "구름"에서 "토끼"를 찾는 것과 같습니다.

#### 어떻게 방지할까?

감지 방법은 잘 알려져 있습니다: **표본 외 데이터(out-of-sample data)**에서 모델을 테스트하고, 통과하지 못하면 모델을 버려야 합니다. 하지만 말처럼 쉬운 일이 아닙니다. 수주간 공들인 모델을 완전히 버릴 의지가 정말 있으신가요? 우리 대부분은 모델을 이리저리 수정해서 표본 내(in-sample)와 표본 외 모두에서 합리적으로 작동하게 만들 것입니다. 하지만 이렇게 하면 **표본 외 데이터를 사실상 표본 내 데이터로 전환**해 버린 셈입니다!

고정된 표본 외 데이터만으로 모델을 판단하고 싶지 않다면(그 데이터에서의 저조한 성과가 단지 운이 나빠서일 수도 있으니까), 또는 애초에 데이터가 부족하다면, **교차 검증(cross-validation)**을 고려해야 합니다. 데이터의 여러 부분 집합을 돌아가며 훈련/테스트하고, 모델이 이 다양한 부분 집합에서 일관되게 잘 수행되는지 확인하는 것입니다. 높은 **샤프 비율(Sharpe ratio)**과 짧은 **최대 손실 기간(maximum drawdown duration)**을 가진 모델은 거의 자동으로 교차 검증을 통과합니다. 손실 기간이 짧다는 것은 어떤 구간을 뽑아도 대부분 수익이 난다는 뜻이니까요.

#### 단순함의 힘 — 선형 모델의 우월성

데이터 스누핑 편향을 최소화하는 가장 좋은 접근법은 **가능한 한 적은 매개변수로, 가능한 한 단순한 모델**을 만드는 것입니다.

여기서 중요한 통찰이 있습니다: 매개변수가 적더라도 **복잡한 거래 규칙이 많은 모델**도 데이터 스누핑에 마찬가지로 취약합니다. 두 원칙 모두 하나의 결론으로 수렴합니다: **비선형 모델(nonlinear models)보다 선형 모델(linear models)이 더 안전하다.** 비선형 모델은 더 복잡하고 일반적으로 더 많은 자유 매개변수를 가지기 때문입니다.

과거 가격으로 미래 가격을 예측하려 한다고 합시다. 비선형 모델은 과거 데이터에 확실히 더 잘 맞겠지만(구불구불한 곡선이 직선보다 데이터 포인트를 더 많이 지나갈 수 있으니까), 미래를 더 잘 예측한다는 보장은 없습니다. 미적분학의 **테일러 급수 전개(Taylor-series expansion)**를 떠올려 보세요. 모든 비선형 모델은 선형 모델로 근사할 수 있습니다. 즉, 대부분의 비선형 모델에는 대응하는 더 단순한 선형 근사가 존재하며, 선형 모델을 사용하지 않는 데는 **타당한 이유가 있어야** 합니다. (저차항이 사라지는 예외적 경우를 제외하면, 이런 경우는 현실 금융 시계열에서 거의 나타나지 않습니다.)

확률 분포의 선택에서도 같은 논리가 적용됩니다. **가우시안 분포(Gaussian distribution)**가 극단적 사건을 포착하지 못한다는 비판을 자주 듣습니다. 맞는 말입니다. 하지만 대안은요? 왜도(skew)와 첨도(kurtosis)를 포착할 수 있는 **스튜던트 *t*-분포**? 유한한 2차 모멘트를 완전히 없애는 **파레토 분포(Pareto distribution)**? 어떤 것을 선택하든 자의적인 면이 있고, 유한한 데이터로 결정해야 합니다. **오컴의 면도날(Occam's razor)** — "불필요한 복잡성을 추가하지 마라" — 은 비가우시안 분포를 지지하는 강력한 이론적/경험적 이유가 없는 한 가우시안 형태를 가정하라고 말합니다.

#### 선형 모델의 실전 적용

선형 모델은 가격 예측뿐 아니라 **자본 배분**에서도 선형성을 의미합니다. 예를 들어, 가격이 평균으로 돌아오는 **평균 회귀(mean-reverting)** 모델을 생각해 봅시다. 다음 시간 $dt$ 동안의 가격 변화 $dy$가 평균 가격과 현재 가격의 차이에 비례한다고 가정합니다:

$$dy(t) = (\lambda y(t - 1) + \mu)dt + d\epsilon$$

이것이 이른바 **"오른스타인-울렌벡(Ornstein-Uhlenbeck)"** 공식으로, 2장에서 더 자세히 설명합니다. 각 변수를 살펴보면:

- $dy(t)$: 시간 $t$에서의 가격 변화량
- $\lambda$: 평균으로 되돌아오는 속도를 나타내는 계수 (음수값)
- $y(t-1)$: 이전 시점의 가격
- $\mu$: 장기 평균에 관련된 상수
- $dt$: 미소 시간 간격
- $d\epsilon$: 랜덤 노이즈 (예측 불가능한 변동)

많은 트레이더들이 **볼린저 밴드(Bollinger band)** 모델을 사용하여 가격이 특정 임계값을 초과하면 매도하고, 미달하면 매수합니다. 하지만 선형 모델을 고수한다면, 모든 가격 움직임마다 점진적으로 매수 또는 매도해야 합니다. 총 시장 가치는 평균으로부터의 편차에 비례하게 됩니다. 트레이더 용어로 이것을 **"평균 매수(averaging-in)"** 또는 **"분할 매수(scaling-in)"**라 하며, 3장에서 더 자세히 다룹니다.

이 책에서 선형 거래 모델의 여러 예를 찾을 수 있습니다. 이 기법의 단순성은 수익이 전략의 미묘하고 복잡한 영리함에서 나오는 것이 아니라 평범하게 보이는 곳에 숨겨진 **시장의 본질적인 비효율성**에서 나온다는 점을 설명할 수 있게 합니다. 조급한 독자는 예제 4.2를 미리 볼 수 있는데, 이는 상장지수펀드(ETF)와 그 구성 종목 간의 선형 평균 회귀 전략을 보여주며, 예제 4.3과 4.4는 주식에 대한 두 가지 선형 롱-숏 통계적 차익거래(statistical arbitrage) 전략을 보여줍니다.

#### 가장 극단적인 선형 모델: 동일 가중치

선형 예측 모델의 가장 극단적인 형태는 **모든 계수의 크기가 같은** 것입니다(반드시 부호가 같을 필요는 없습니다). 예를 들어, 주식 수익률 예측에 여러 요인(*f*)을 사용한다고 합시다. 한 요인은 오늘의 수익률이고(양의 오늘 수익률이 양의 미래 수익률을 예측), 다른 요인은 변동성 지수(VIX) 변화일 수 있습니다(음의 변화가 양의 미래 수익률을 예측). 이 요인들을 먼저 **Z-점수(Z-scores)**로 정규화합니다:

$$z(i) = \frac{f(i) - \text{mean}(f)}{\text{std}(f)} \qquad (1.1)$$

이 수식이 하는 일을 풀어보면:

- $f(i)$: $i$번째 요인의 현재 값
- $\text{mean}(f)$: 이 요인의 과거 평균
- $\text{std}(f)$: 이 요인의 과거 표준편차
- $z(i)$: 정규화된 점수 — "평균에서 표준편차 몇 개만큼 떨어져 있는가"를 나타냄

왜 정규화할까요? 서로 다른 요인들의 단위와 크기가 다르기 때문입니다. 키(cm)와 체중(kg)을 비교하려면 같은 척도로 맞춰야 하듯이요.

그런 다음 내일의 수익률 *R*을 다음과 같이 예측합니다:

$$R = \text{mean}(R) + \text{std}(R) \frac{\sum_{i=1}^{n} \text{sign}(i)z(i)}{n} \qquad (1.2)$$

각 변수의 의미:

- $\text{mean}(R)$: 1일 수익률의 과거 평균
- $\text{std}(R)$: 1일 수익률의 과거 표준편차
- $\text{sign}(i)$: $f(i)$와 수익률 $R$ 사이의 과거 상관관계의 부호 (+1 또는 -1)
- $n$: 사용하는 요인의 총 개수
- $z(i)$: 식 1.1에서 계산한 정규화된 요인 값

노벨 경제학상 수상자 **다니엘 카너먼(Daniel Kahneman)**은 그의 베스트셀러 *생각에 관한 생각(Thinking, Fast and Slow)*에서 "**모든 예측 변수에 동일한 가중치를 할당하는 공식은 표본 추출의 우연에 영향을 받지 않기 때문에 종종 우수하다**"(Kahneman, 2011)고 했습니다. 식 1.2는 주식 수익률 예측에 사용되는 일반적인 요인 모델의 단순화된 버전입니다. 절대 수익률 예측은 정확하지 않을 수 있지만, 주식 간의 **상대 수익률** 예측은 종종 충분히 좋습니다. 상위 십분위수 주식을 매수하고 하위 십분위수를 공매도하면, 평균 수익률이 양수인 경우가 많습니다.

#### 순위 기반 접근법

목표가 기대 수익률이 아니라 **주식의 순위**를 매기는 것이라면, 식 1.1과 1.2를 사용하지 않고 더 간단한 방법이 있습니다. 요인 $f(i)$에 기반하여 주식 $s$의 순위를 계산하고, 상관관계 부호를 곱한 뒤, 모두 합산합니다:

$$\text{rank}_s = \sum_{i=1}^{n} \text{sign}(i) \text{rank}_s(i) \qquad (1.3)$$

이 수식이 하는 일:

- $\text{rank}_s(i)$: $i$번째 요인에 따른 주식 $s$의 순위 (예: 100개 주식 중 몇 번째인지)
- $\text{sign}(i)$: 해당 요인과 수익률 사이의 상관관계 부호
- $\text{rank}_s$: 최종 종합 순위

**조엘 그린블라트(Joel Greenblatt)**가 유명한 두 요인 **"마법 공식(magic formula)"**으로 이 방법을 사용했습니다: $f(1)$ = **투하자본수익률(return on capital)**, $f(2)$ = **이익 수익률(earnings yield)** (Greenblatt, 2006). 상위 30개 주식을 매수하고 1년간 보유하면, 1988~2004년 **연간 수익률(APR)이 30.8%**로, S&P 500의 12.4%를 크게 앞섰습니다. 선형성의 놀라운 승리입니다!

#### 워크포워드 테스트: 궁극의 검증

아무리 조심해도 데이터 스누핑 편향은 어떻게든 모델에 스며들 수 있습니다. 여러분이 의식적으로 피하려 해도, 무의식적으로 "이 매개변수를 살짝 바꾸면 결과가 더 좋아지는데..."라는 유혹에 빠지게 됩니다. 이것은 인간의 본성입니다.

따라서 최종적이고 진정한 표본 외 테스트로서 **워크포워드 테스트(walk-forward test)**를 수행해야 합니다. 이 테스트는 모의 거래(paper trading) 형태로 할 수 있지만, 더 좋은 것은 **실제 자금**(최소한의 레버리지)으로 거래하는 것입니다. 왜 모의 거래가 아닌 실제 자금이어야 할까요? 모의 거래에서는 드러나지 않는 **슬리피지(slippage)**, 주문 체결 실패, 유동성 부족 같은 실행 문제가 실제 거래에서만 나타나기 때문입니다. 또한 실제 돈이 걸려 있을 때와 아닐 때의 심리적 차이도 무시할 수 없습니다.

대부분의 트레이더들은 실시간 거래가 **백테스트 샤프 비율의 절반**보다 나은 결과를 보이면 만족할 것입니다. 이것이 비관적으로 들릴 수 있지만, 현실적인 기대치입니다. 백테스트에서 샤프 비율 2.0이 나왔다면, 실시간에서 1.0 이상이면 성공이라고 볼 수 있습니다.

### 1.2.3 주식 분할과 배당 조정 — 가격 데이터의 덫

#### 주식 분할이 백테스트를 어떻게 속이나

회사의 주식이 $N$ 대 1 분할을 하면, 주가는 $N$배로 나뉩니다. 하지만 분할 전에 100주를 갖고 있었다면 분할 후에는 $N \times 100$주가 되므로, **총 시장 가치는 변하지 않습니다**. 주식 분할은 피자를 8조각으로 자르든 16조각으로 자르든 피자의 총 크기는 같은 것과 마찬가지입니다.

**구체적인 예를 들어 보겠습니다.** 어떤 회사의 주가가 200달러이고, 2대1 분할을 결정했다고 합시다. 분할 후 주가는 100달러가 되지만, 주식 수가 두 배가 되므로 여러분이 보유한 총 가치는 동일합니다. 200달러 x 100주 = 20,000달러가, 100달러 x 200주 = 20,000달러로 바뀌는 것이죠. 아무 일도 일어나지 않은 셈입니다.

문제는 백테스트에서 보통 **가격 시계열**만 보고 거래 신호를 결정한다는 점입니다. 분할 기준일(ex-date) 이전의 가격을 $N$으로 나눠 역조정하지 않으면, 기준일에 **가격이 갑자기 급락한 것처럼** 보입니다.

**비유로 설명하면 이렇습니다:** 여러분이 체중 기록을 킬로그램으로 관리하고 있었는데, 어느 날부터 파운드로 기록하기 시작했다고 합시다. 그래프를 그려보면 체중이 갑자기 2.2배로 뛰어오른 것처럼 보일 것입니다. 실제로는 단위가 바뀌었을 뿐인데 말이죠. 주식 분할도 마찬가지입니다. 가격의 "단위"가 바뀌었을 뿐인데, 이를 모르는 알고리즘은 "갑자기 50% 폭락했다! 매수 신호다!"라고 잘못 판단할 수 있습니다.

이것이 잘못된 거래 신호를 유발할 수 있습니다. 이 조정은 백테스팅뿐 아니라 **실시간 거래에서도** 필요합니다 — 기준일에 시장이 열리기 직전에 과거 가격을 $N$으로 나눠야 합니다. (1 대 $N$ 역분할의 경우에는 기준일 이전 가격에 $N$을 곱해야 합니다.)

**실전에서 흔히 발생하는 실수:** 많은 초보 트레이더들이 무료 데이터 소스에서 주가 데이터를 다운로드하면서 분할 조정 여부를 확인하지 않습니다. Yahoo Finance 같은 곳에서 "Adj Close(조정 종가)"와 "Close(종가)" 컬럼이 따로 있는 이유가 바로 이것입니다. 조정되지 않은 종가를 사용하면 분할이 있었던 모든 날짜에서 가짜 신호가 발생합니다.

#### 배당도 같은 문제를 일으킨다

마찬가지로, 회사가 주당 *d*의 현금(또는 주식) 배당을 지급하면, 주가도 *d*만큼 하락합니다(다른 시장 움직임이 없는 경우). 배당을 받으므로 총 가치는 변하지 않지만, 가격 시계열만 보면 급락으로 보입니다.

**구체적인 예를 들어 보겠습니다.** 주가 50달러인 회사가 주당 2달러의 분기 배당을 발표했습니다. 배당 기준일에 주가는 자동으로 48달러로 조정됩니다. 주주는 주당 2달러를 현금으로 받으므로 총 가치는 여전히 50달러입니다. 하지만 조정되지 않은 차트를 보면, 하루 만에 4% 하락한 것처럼 보입니다. 평균 회귀 모델이라면 "4% 하락? 매수 기회다!"라고 잘못된 신호를 보낼 것입니다.

기준일 이전의 가격을 역조정하지 않으면 잘못된 거래 신호가 발생합니다. 이 조정 역시 기준일에 시장이 열리기 직전에 실시간 거래 모델에 사용되는 모든 과거 데이터에 적용되어야 합니다. (이 논의는 ETF에도 동일하게 적용됩니다. 옵션 가격에는 약간 더 복잡한 처리가 필요합니다.)

**특히 조심해야 하는 경우가 있습니다.** 고배당 REITs(부동산 투자 신탁)나 배당 성장주 같은 종목은 분기마다 한 번씩 이 문제가 발생합니다. 매달 배당을 지급하는 종목이라면 매달 한 번씩 가짜 신호가 나올 수 있습니다. 또한 **특별 배당(special dividend)**의 경우 주가의 10% 이상이 한꺼번에 떨어질 수 있어 더욱 큰 왜곡을 만들 수 있습니다.

과거 분할 및 배당 정보는 earnings.com에서 무료로 확인할 수 있으며(미래 예정 분할/배당 정보도 포함), 이미 조정된 과거 데이터는 csidata.com에서 쉽게 다운로드할 수 있습니다.

> **핵심 정리**: 주식 분할과 배당은 "가격의 단위가 바뀌는 것"이지 실제 가치가 변하는 것이 아닙니다. 이 차이를 무시하면 백테스트에서 존재하지 않는 거래 기회를 "발견"하게 됩니다.

### 1.2.4 주식 데이터베이스의 생존자 편향 — 죽은 주식이 빠진 명단의 위험

**생존자 편향(survivorship bias)**은 과거 데이터에 **상장 폐지된 주식이 포함되어 있지 않을 때** 발생합니다.

**비유로 설명하면 이렇습니다:** 여러분이 어느 대학의 졸업생 중 성공한 사람만 인터뷰하고, "이 학교의 교육이 훌륭하다"고 결론 내리는 것과 같습니다. 중퇴하거나 취업에 실패한 졸업생(=상장 폐지된 주식)은 명단에 없으니, 전체 그림이 심각하게 왜곡됩니다. 2차 세계대전 당시 통계학자 아브라함 발트(Abraham Wald)의 유명한 사례를 떠올려 보세요. 돌아온 폭격기의 총탄 구멍 위치만 보고 장갑을 보강하려 했지만, 발트는 "돌아오지 못한 폭격기가 진짜 취약한 부분에 맞았다"고 지적했습니다. 생존자 편향은 바로 이 "돌아오지 못한 것들"을 무시하는 오류입니다.

극단적인 예를 들어봅시다. 모델이 "전일 가장 많이 하락한 주식을 매수하고 영원히 보유"하라고 한다면? 실제로 이 전략은 거의 확실히 실패합니다. 크게 하락한 주식의 회사가 파산으로 이어져 100% 손실을 초래하는 경우가 많기 때문입니다. 2008년 금융 위기 당시를 떠올려 보세요. 베어스턴스, 리먼 브라더스, 워싱턴 뮤추얼 같은 회사들의 주가가 며칠 사이에 90% 이상 폭락했고, 결국 상장 폐지되었습니다.

하지만 데이터에 오늘까지 **살아남은 주식만** 포함되어 있다면, 백테스트 결과는 환상적으로 보일 수 있습니다. 크게 하락했지만 결국 살아남은 "운 좋은" 주식만 선택하게 되니까요. 예를 들어, 2009년에 주가가 1달러까지 떨어졌던 씨티그룹(C)은 오늘날 살아남아 데이터에 포함되어 있습니다. 하지만 비슷하게 폭락했던 수십 개의 다른 금융주는 파산하여 데이터에서 사라졌습니다. 생존자 편향이 있는 데이터는 씨티그룹만 보여주므로 "폭락한 주식을 사면 대박이다!"라는 잘못된 결론을 내리게 합니다. 하지만 전략을 실시간으로 거래했다면 어떤 주식이 최종적으로 살아남을지 예측할 수 없었을 것입니다.

생존자 편향의 영향은 전략 유형에 따라 크게 다릅니다. 각 유형별로 자세히 살펴보겠습니다:

- **평균 회귀 롱 온리(long-only) 전략**: **가장 위험합니다.** 이 전략은 "많이 떨어진 주식은 다시 오를 것이다"라는 논리에 기반합니다. 하지만 파산하여 상장 폐지된 주식(= 떨어지고 다시는 오르지 못한 주식)이 데이터에서 빠져 있으므로, 생존한 주식만 대상으로 하면 "떨어지면 항상 다시 오른다!"라는 환상적인 결과가 나옵니다. 마치 전투에서 살아 돌아온 병사들만 보고 "전쟁은 안전하다"고 결론 짓는 것과 같습니다.

- **숏 온리(short-only) 전략**: **반대 효과**입니다. 가격이 0으로 간 주식은 공매도에서 최대 수익을 주는 최고의 거래입니다. 그런데 이 주식들이 데이터에 없으므로, 생존자 편향이 있는 데이터에서 숏 전략의 성과는 오히려 **과소평가**됩니다. 최고의 성공 거래가 누락되니까요.

- **롱-숏(long-short) 전략**: 롱 쪽의 부풀림과 숏 쪽의 감소가 서로 상쇄됩니다. 하지만 완전히 제거되지는 않습니다. 일반적으로 롱 쪽의 부풀림 효과가 숏 쪽의 감소 효과보다 크기 때문에, 전체적으로는 여전히 성과가 약간 부풀려지는 경향이 있습니다.

- **모멘텀(momentum) 전략**: 상대적으로 **덜 위험**합니다. 모멘텀 전략은 하락하는 주식을 공매도하는데, 가격이 0으로 간 주식(= 최고의 숏 거래)이 데이터에 없으므로 오히려 백테스트 수익률이 감소합니다. 즉, 생존자 편향이 모멘텀 전략의 성과를 보수적으로 만드는 셈이므로, 실시간 결과가 백테스트보다 나을 수 있습니다.

#### 생존자 편향을 어떻게 피할 수 있을까?

가장 좋은 방법은 **생존자 편향이 없는(survivorship-bias-free) 데이터**를 사용하는 것입니다. 이런 데이터에는 상장 폐지된 주식의 가격 기록도 포함되어 있습니다. csidata.com(상장 폐지된 주식 목록 제공), kibot.com, tickdata.com, crsp.com에서 구매할 수 있습니다.

데이터를 구매할 여력이 없다면, **직접 데이터를 수집**할 수도 있습니다. 매일 인덱스(예: S&P 500, 나스닥 100)의 모든 구성 종목 가격을 자동으로 저장하는 스크립트를 만들면, 시간이 지나면서 상장 폐지된 종목의 데이터도 자연스럽게 포함됩니다. 오늘 시작하면 1년 후에는 1년치 생존자 편향 없는 데이터를 갖게 되는 셈입니다.

이런 데이터에 접근할 수 없다면, 최근 **3년 정도의 데이터**로 백테스팅을 제한하여 피해를 줄일 수 있습니다. 기간이 짧을수록 그 기간 동안 상장 폐지된 주식의 수가 적으므로 생존자 편향의 영향이 줄어듭니다. 하지만 이것은 차선책일 뿐이며, 통계적 유의성을 얻기에 데이터가 부족해지는 트레이드오프가 있습니다.

### 1.2.5 1차 거래소 대 통합 주가 — 어떤 가격을 믿어야 할까?

이 함정은 약간 기술적이지만, 이해하고 나면 "왜 내 백테스트와 실제 거래 결과가 다른가?"에 대한 중요한 답을 줍니다.

많은 미국 주식은 **뉴욕증권거래소(NYSE)**, NYSE Arca, **나스닥(Nasdaq)**, Island, BATS, Instinet, Liquidnet, Bloomberg Tradebook, Goldman Sachs의 Sigma X, Credit Suisse의 CrossFinder 등 여러 거래소, 전자 통신 네트워크(ECN), **다크 풀(dark pools)**에서 동시에 거래됩니다.

**비유로 설명하면 이렇습니다:** 같은 책이 교보문고, 알라딘, 인터넷 서점에서 동시에 팔리는 것을 상상해 보세요. 대부분의 시간에는 가격이 같지만, 특정 순간에는 서점마다 가격이 조금씩 다를 수 있습니다. 특히 마감 시간이 다르다면, "오늘의 최저가"가 어느 서점에서 기록된 것인지에 따라 달라지겠죠.

과거 일일 종가를 조회하면, 이는 이런 거래소들 중 **어디서든** 마지막으로 체결된 가격(통합 가격)을 반영합니다. 시가도 마찬가지로 어느 거래소에서든 첫 번째 체결 가격입니다. 하지만 **종가 시장가 주문(MOC)** 또는 **시가 시장가 주문(MOO)**을 제출하면, 항상 **1차 거래소(primary exchange)**로만 라우팅됩니다. IBM이라면 NYSE, SPY라면 NYSE Arca, MSFT라면 나스닥으로요.

따라서 MOC나 MOO 주문에 의존하는 전략이라면, **1차 거래소의 과거 가격**으로 백테스트해야 합니다. 일반적인 통합 가격을 사용하면 비현실적인 결과가 나올 수 있습니다. 특히 평균 회귀 모델에서는, 소량의 주식이 1차 거래소 경매 가격과 상당히 다른 가격으로 다른 거래소에서 체결될 수 있고, 다음 거래일에는 이 이상치 가격에서 평균으로 회귀하므로 비현실적인 수익이 만들어집니다. (미국 1차 거래소의 종가와 시가는 항상 경매로 결정되는 반면, 2차 거래소 종가는 경매 결과가 아닙니다.)

고가나 저가를 사용하는 전략에도 같은 문제가 적용됩니다. 과거 데이터에 기록된 것은 보통 통합 고가/저가이지 1차 거래소의 것이 아니며, 이것들은 종종 2차 거래소에서의 소량 거래로 인한 대표성 없는 과장된 수치입니다.

1차 거래소 과거 가격은 **블룸버그(Bloomberg)** 구독자라면 접근할 수 있고, 거래소의 직접 실시간 피드를 구독하여 자체 데이터베이스를 구축할 수도 있습니다. **Lime Brokerage** 같은 기관 브로커는 코로케이션 고객에게 이런 데이터를 제공합니다. 대부분의 리테일 브로커는 거래소 직접 피드를 재배포하지 않습니다. 이런 데이터에 접근할 수 없다면, 백테스트 결과에 대한 **건전한 회의론**을 가지는 것이 최선입니다.

> **핵심 정리**: 데이터에 기록된 "종가"와 여러분의 주문이 실제로 체결되는 "종가"가 다를 수 있습니다. 통합 가격은 모든 거래소를 합친 것이고, MOC/MOO 주문은 1차 거래소에서만 체결됩니다. 이 차이가 백테스트와 실전 사이의 괴리를 만듭니다.

### 1.2.6 통화 시세의 거래소 의존성 — 더욱 파편화된 세계

주식 시장에서 가격의 거래소 의존성이 문제라면, **통화(외환, FX) 시장은 이 문제가 훨씬 더 심각**합니다. 왜일까요?

주식 시장은 적어도 **NMS(National Market System)** 규정이 있어, 한 거래소에서 더 좋은 가격이 있으면 주문이 그쪽으로 라우팅되어야 합니다. 하지만 통화 시장에는 이런 규정이 **존재하지 않습니다**. 각 거래소, 은행, ECN이 완전히 독립적으로 가격을 제시합니다. 마치 같은 물건이 여러 나라의 시장에서 팔리는데, 각 나라의 가격을 통일하는 국제법이 없는 것과 같습니다.

따라서 백테스트는 **실제로 거래할 거래소에서 추출한 과거 데이터**를 사용할 때만 현실적입니다.

Streambase와 같은 시세 통합기가 여러 거래소의 데이터를 하나의 **주문장(order book)**으로 통합합니다. 통합된 주문장에 포함된 거래소에서 실행할 수 있다면, 통합 데이터를 백테스팅에 사용할 수 있습니다.

통화 시장의 또 다른 특징은 **거래 가격과 거래량이 일반적으로 이용 불가능**하거나 최소한 약간의 지연 없이는 이용 불가능하다는 점입니다. 딜러나 ECN이 거래 가격을 보고해야 한다는 규정이 없기 때문입니다. 실제로 많은 딜러들은 거래 정보를 독점적이고 가치 있는 정보로 간주합니다. (7장에서 언급되듯이 주문 흐름 정보에 의존하는 고빈도 전략이 있으므로, 은행의 외환 자기매매 데스크가 이 정보를 자신들만 보유하려는 것은 합리적입니다.)

같은 통화쌍의 **매수-매도 스프레드**가 거래소 간에 상당히 다를 수 있으므로, 외환 전략 백테스팅에는 **매수-매도 시세를 사용하는 것이 권장**됩니다. 결과적으로 거래 비용도 거래소에 크게 의존하므로 백테스트에 반영해야 합니다.

**왜 이것이 특히 중요할까요?** 외환 전략은 종종 매우 작은 가격 차이를 이용합니다. EUR/USD의 스프레드가 한 거래소에서 0.5핍이고 다른 거래소에서 2.0핍이라면, 같은 전략이라도 거래 비용이 4배 차이 납니다. 한쪽에서는 수익이 나고 다른 쪽에서는 손실이 날 수 있습니다. 거래소 A의 데이터로 백테스트하고 거래소 B에서 실제 거래하면, 결과가 완전히 달라질 수 있는 것입니다.

> **핵심 정리**: 외환 시장은 주식 시장보다 훨씬 파편화되어 있으므로, 반드시 **실제 거래할 거래소의 데이터**로 백테스트해야 합니다. 특히 매수-매도 스프레드 차이가 전략의 수익성을 좌우할 수 있습니다.

### 1.2.7 공매도 제약 — 팔고 싶어도 팔 수 없는 경우

**공매도(short-selling)**를 포함하는 전략에서 자주 간과되는 함정입니다.

**먼저 공매도의 기본 원리를 짚어 보겠습니다.** 일반적인 주식 거래는 "싸게 사서 비싸게 판다"입니다. 공매도는 이것의 반대입니다: "비싸게 팔고, 나중에 싸게 사서 되갚는다"입니다. 어떻게 가능할까요? 여러분이 가지고 있지 않은 주식을 다른 사람에게 빌려서 먼저 팔고, 나중에 가격이 떨어지면 다시 사서 돌려주는 것입니다. 마치 친구에게 교과서를 빌려서 중고 서점에 팔고, 나중에 더 싼 중고 교과서를 사서 돌려주는 것과 비슷합니다.

이 과정에서 핵심이 되는 것이 **"주식 대차(stock borrowing)"**입니다. 주식을 공매도하려면, 브로커가 다른 고객이나 기관(보통 큰 롱 포지션을 가진 뮤추얼 펀드나 자산 운용사)으로부터 주식을 **"확보(locate)"**하고 대차를 주선해야 합니다.

문제는 일부 주식이 **"대차 곤란(hard to borrow)"**인 경우입니다:

- 이미 큰 공매도 잔고가 있거나, 주식의 **유통 물량(float)**이 제한적이라면 대차가 어렵습니다
- 대차 곤란은 공매도자가 주식 대여자에게 **이자를 지불**해야 한다는 뜻일 수 있습니다 (정상적으로는 반대)
- 극단적인 경우, 원하는 수량 또는 아예 주식을 빌릴 수 없을 수도 있습니다

2008-2009년 금융 위기 때 **리먼 브라더스(Lehman Brothers)**가 붕괴한 후, 미국 **증권거래위원회(SEC)**는 수개월 동안 **모든 금융주의 공매도를 금지**했습니다. 심지어 **SPY**조차 빌릴 수 없었습니다! 백테스팅 모델이 대차가 어렵거나 불가능한 주식을 공매도한다면, 다른 누구도 공매도하여 가격을 떨어뜨릴 수 없었으므로 놀라운 수익률을 보여줄 수 있습니다. 하지만 이 수익률은 완전히 비현실적입니다.

대차 곤란 주식의 역사적으로 정확한 목록을 찾기는 쉽지 않으며, 어떤 브로커를 사용하느냐에 따라 달라집니다. 일반 규칙으로, **소형주(small-cap stocks)**가 **대형주(large-cap stocks)**보다 공매도 제약의 영향을 훨씬 더 받습니다.

추가적인 공매도 제약으로 SEC가 부과한 **"업틱 규칙(uptick rule)"**이 있습니다:

- **원래 업틱 규칙** (1938~2007): 공매도는 마지막 거래 가격보다 높은 가격에서, 또는 그 가격이 마지막 이전 거래 가격보다 높았다면 마지막 거래 가격에서 실행되어야 했습니다. (나스닥 주식의 경우 마지막 매수호가보다 높아야 합니다.)
- **대안적 업틱 규칙** (2010~): 공매도가 전국 최우선 매수호가보다 높은 거래 가격을 가져야 하지만, **서킷 브레이커(circuit breaker)**가 발동된 경우에만 적용됩니다. 주식이 전일 종가보다 **10% 하락**하면 서킷 브레이커가 발동되며, 다음 날에도 효력이 있습니다. 이는 사실상 모든 공매도 시장가 주문의 체결을 방지합니다.

정확한 백테스트라면 이러한 제약이 해당 시점에 시행되고 있었는지를 고려해야 합니다. 그렇지 않으면 백테스트 성과가 부풀려질 것입니다.

> **핵심 정리**: 백테스트에서 "공매도"라고 명령하면 컴퓨터는 아무 저항 없이 실행합니다. 하지만 실제 세계에서는 빌릴 수 없는 주식, 공매도 금지, 업틱 규칙 등 수많은 제약이 있습니다. 백테스트 프로그램은 이 현실을 모르므로, 여러분이 직접 확인해야 합니다. 특히 소형주를 공매도하는 전략은 이 문제에 가장 취약합니다.

### 1.2.8 선물 연속 계약 — 이어 붙이기의 기술

이 함정은 **선물(futures)** 시장에만 해당되지만, 선물을 거래하는 트레이더에게는 매우 중요합니다. 주식과 달리 선물 계약에는 **만기일(expiration date)**이 있습니다.

**비유로 설명하면 이렇습니다:** 선물 계약은 마치 유통기한이 있는 우유와 같습니다. 유통기한이 지나면 더 이상 사용할 수 없으므로, 기한 전에 새 우유를 사야 합니다. 원유 선물 전략이라면 실제로는 여러 다른 만기의 계약을 순서대로 거래하는 것입니다. 보통 전략은 **최근월물(front-month)** 계약에 적용되며, 만기가 가까워지면 다음 월물로 **"롤오버(roll over)"**합니다 — 현재 계약을 매도하고 다음 계약을 매수하는 것이죠(롱 포지션의 경우). 빈 우유병을 반납하고 새 우유를 사오는 것과 비슷합니다.

롤오버 시점을 결정하는 방법은 여러 가지입니다. 만기 10일 전에 할 수도 있고, **미결제 약정 교차(open interest crossover)** — 다음 계약의 미결제 약정이 현재 계약을 초과할 때 — 에 맞출 수도 있습니다. 롤오버 매수와 매도는 전략 자체와 무관하며 최소한의 추가 손익을 초래해야 합니다. (손익이나 수익률은 이른바 "롤 수익률(roll return)"의 영향을 받지만, 5장에서 논의하듯이 롤 수익률은 매일 모든 계약에 효력이 있으며 롤오버의 결과가 아닙니다.) 이런 복잡함을 줄이기 위해 대부분의 데이터 업체는 **"연속 계약(continuous contract)"** 데이터를 제공합니다.

#### 연속 계약의 함정: 손익과 수익률을 동시에 맞출 수 없다

연속 계약을 만드는 첫 단계는 최근월물 계약의 가격을 이어 붙이는 것입니다. 하지만 여기서 근본적인 문제가 발생합니다. 롤오버 시점에 이전 계약과 새 계약의 가격이 다르므로 **가격 갭**이 발생하고, 이것이 잘못된 수익률이나 손익 계산으로 이어집니다.

**비유로 설명하면 이렇습니다:** 여러분이 매달 새 체중계로 바꾼다고 상상해 보세요. 이번 달 체중계는 70kg을 보여주고, 다음 달 새 체중계는 72kg을 보여줍니다. 여러분이 정말 2kg 찐 건지, 아니면 단지 체중계의 보정이 다른 건지 구분해야 합니다. 선물 연속 계약에서 롤오버 시 발생하는 가격 갭도 이와 같습니다. 실제 손익과 측정 오차를 구분해야 합니다.

구체적으로 살펴봅시다. 날짜 $T$에서 최근 계약의 종가가 $p(T)$이고, 같은 계약의 $T+1$ 종가가 $p(T+1)$입니다. $T+1$에서 원월물(back) 계약의 종가가 $q(T+1)$이고, $T+1$이 롤오버 날짜라면:

- **실제 손익** (포인트 기준): $p(T+1) - p(T)$
- **실제 수익률**: $(p(T+1) - p(T))/p(T)$

하지만 조정되지 않은 연속 시계열은 $T$에서 $p(T)$, $T+1$에서 $q(T+1)$을 보여주므로, 잘못된 값 $q(T+1) - p(T)$가 계산됩니다.

**가격 역조정 방법**: $T$ 이전의 모든 날짜 $t$의 가격 $p(t)$에 $(q(T+1) - p(T+1))$를 더합니다. 이러면 $T$에서 $T+1$까지의 가격 변화가 $q(T+1) - (p(T) + q(T+1) - p(T+1)) = p(T+1) - p(T)$로 **손익이 올바르게** 계산됩니다. (모든 롤오버를 처리하려면, 먼 과거로 갈수록 이 역조정을 여러 번 적용해야 합니다.)

하지만 문제가 해결된 것이 아닙니다! 조정된 시계열에서 $T+1$의 **수익률**을 확인해 보면 $(p(T+1) - p(T))/(p(T) + q(T+1) - p(T+1))$이며, 올바른 값 $(p(T+1) - p(T))/p(T)$가 아닙니다. 손익 계산을 올바르게 하면 수익률이 틀리고, 수익률을 올바르게 하면($T$ 이전 가격에 $q(T+1)/p(T+1)$을 곱하여) 손익이 틀립니다. **두 가지를 동시에 올바르게 할 수는 없습니다.** 연속 계약의 편의를 원한다면, 손익 또는 수익률 중 **하나만 선택**해야 합니다. (개별 계약별로 백테스트하고 롤오버를 직접 처리하면 둘 다 올바르게 계산할 수 있습니다.)

**이 딜레마를 정리하면 다음과 같습니다:**

| 역조정 방식 | 장점 | 단점 |
|-------------|------|------|
| **가격 역조정** (더하기/빼기) | 손익(P&L) 정확 | 수익률 부정확 |
| **수익률 역조정** (곱하기/나누기) | 수익률 정확 | 손익 부정확, 음수 가격 가능 |

수익률 역조정을 선택하면 먼 과거의 가격이 **음수**가 될 수 있다는 추가 문제가 있습니다. 이를 해결하는 일반적인 방법은 모든 가격에 상수를 더하는 것입니다.

**스프레드 전략에서의 중요성**: 두 계약 간의 **가격 차이**에 기반한 전략이라면 가격 역조정을 선택해야 합니다. **가격 비율**에 기반한 전략이라면 수익률 역조정을 선택해야 합니다. **캘린더 스프레드(calendar spreads)**에서는 스프레드 자체가 작은 수이므로, 롤오버로 인한 오류가 스프레드의 상당한 비율이 되어 잘못된 신호를 유발할 가능성이 매우 높습니다.

데이터 업체마다 역조정 방식이 다릅니다. csidata.com은 가격 역조정만 사용하지만 음수 가격을 방지하기 위한 선택적 가산 상수가 있고, tickdata.com은 가격 대 수익률 역조정을 선택할 수 있지만 음수 방지 상수 옵션은 없습니다.

### 1.2.9 선물 종가 대 정산 가격 — 어떤 가격이 "진짜"일까?

선물 시장에는 "종가"에 대한 미묘하지만 중요한 구분이 있습니다. 주식 시장에서는 종가가 명확합니다 — 오후 4시에 마지막으로 체결된 가격이 종가입니다. 하지만 선물 시장에서는 이것이 그렇게 간단하지 않습니다.

데이터 업체가 제공하는 선물의 일일 종가는 보통 **정산 가격(settlement price)**이지, 그날 마지막 거래 가격이 아닙니다. **정산 가격**은 거래소가 결정하는 **공식 가격**으로, 그날 계약이 전혀 거래되지 않았더라도 존재합니다. 마치 부동산 공시가격이 실거래가와 다른 것처럼, 정산 가격은 거래소의 위원회가 시장 상황을 종합적으로 고려하여 결정하는 "공식 가격"입니다. 계약이 거래되었다 해도 정산 가격은 보통 마지막 거래 가격과 다릅니다. 일부 업체(틱별 데이터 제공 업체)는 실제 마지막 거래 가격만 제공할 수 있습니다.

대부분의 경우 **정산 가격을 사용해야** 합니다. 마지막 거래 가격은 수시간 전에 발생했을 수 있어 종가 근처의 실제 거래 가격과 관련이 없을 수 있습니다. 이는 선물 **페어 트레이딩(pairs-trading)** 전략에서 특히 중요합니다. 정산 가격을 사용하면 두 **동시 가격**을 사용하고 있음이 보장됩니다(두 계약이 동일한 기초 자산을 가져 같은 마감 시간을 가지는 한). 마지막 거래 가격은 매우 다른 시간에 발생한 가격일 수 있어, 비현실적으로 큰 스프레드와 잘못된 거래, 부풀려진 수익을 만들어낼 수 있습니다.

**일중(intraday) 스프레드 전략**의 경우, 두 계약의 **매수-매도 호가**가 포함된 과거 데이터 또는 거래소에 네이티브한 스프레드 자체의 일중 데이터가 필요합니다. 유동성이 낮은 선물에서 각 봉의 마지막 가격이 시간적으로 꽤 떨어진 거래를 참조할 수 있기 때문입니다. 스프레드의 각 레그의 마지막 가격 대신 스프레드 자체의 마지막 가격을 사용하는 백테스트는 결과 수익률을 부풀립니다. 일중 과거 캘린더 스프레드 데이터를 판매하는 업체로는 cqgdatafactory.com이 있습니다.

**시장 간 스프레드**를 백테스팅할 때는 다른 거래소의 **마감 시간이 다르다**는 점을 주의해야 합니다. 종가로 시장 간 스프레드를 형성하면 잘못됩니다. 선물과 ETF 사이의 스프레드를 형성할 때도 마찬가지입니다.

**구체적인 예를 들어 보겠습니다.** 금 선물 GC의 정산 가격은 동부시간 오후 1:30에 결정되고, 금광 ETF GDX의 종가는 오후 4:00에 결정됩니다. 이 2시간 30분의 시간 차이 동안 금 가격이 크게 움직일 수 있습니다. 두 "종가"를 같은 시점의 가격이라고 가정하고 스프레드를 계산하면, 실제로는 존재하지 않는 가격 차이를 발견하게 됩니다. 이것이 비현실적인 차익거래 기회를 만들어내어 백테스트를 부풀립니다.

해결책은 동시성이 보장된 일중 매수-매도 데이터를 사용하거나, 선물 대신 같은 거래소에서 거래되는 ETF를 사용하는 것입니다. 위 예에서는 금 선물 GC 대신 금 신탁 **GLD**를 GDX에 대해 거래할 수 있습니다. 둘 다 Arca에서 거래되므로 종가가 동일한 동부시간 오후 4시에 설정됩니다.

> **핵심 정리**: 선물의 "종가"는 정산 가격과 마지막 거래 가격이 다릅니다. 또한 서로 다른 거래소의 종가는 서로 다른 시간에 결정되므로, 이들을 비교할 때 "동시성"을 반드시 확인해야 합니다. 이 함정을 무시하면 특히 스프레드 전략에서 비현실적으로 부풀려진 수익을 보게 됩니다.

---

## 1.3 백테스팅의 통계적 유의성: 가설 검정 — 이 결과를 얼마나 믿을 수 있을까?

모든 백테스트에서 우리는 **유한한 표본 크기**의 문제에 직면합니다. 어떤 통계적 측정치를 계산하든 무작위성에 영향을 받습니다. 우리의 전략이 작은 데이터 표본에서 **우연히** 수익성이 있었을 수 있습니다. 동전 던지기를 10번 해서 7번 앞면이 나왔다고 이 동전이 편향되었다고 할 수 있을까요? 10번은 너무 적습니다. 1,000번 던져서 700번 앞면이라면 거의 확실히 편향된 것이겠죠. **가설 검정(hypothesis testing)**은 바로 이 "우연인가, 진짜인가?"를 판별하는 통계적 도구입니다.

### 가설 검정의 프레임워크

백테스팅에 적용되는 가설 검정은 다음 단계를 따릅니다:

1. 유한한 데이터 표본에 대한 백테스트를 기반으로, **검정 통계량(test statistic)**이라는 특정 통계적 측정치를 계산합니다. 예를 들어, 전략의 평균 일일 수익률이 될 수 있습니다.
2. 일일 수익률의 확률 분포가 알려져 있다고 가정합니다. 이 확률 분포는 **귀무가설** — "이 전략의 진정한 수익률은 0이다" — 에 기반하여 평균이 0입니다.
3. 이 귀무가설 확률 분포에 기반하여, 평균 일일 수익률이 백테스트에서 관찰된 값 이상이 될 확률 $p$를 계산합니다. 이 확률 $p$를 **p-값(p-value)**이라 하며, 매우 작으면(예: 0.01 미만) "귀무가설을 기각"할 수 있어, 백테스트된 평균 수익률이 **통계적으로 유의**하다고 결론짓습니다.

쉽게 말해, p-값이 0.01이라는 것은 "전략에 수익 능력이 전혀 없는데 순전히 운으로 이런 결과가 나올 확률이 1%밖에 안 된다"는 뜻입니다.

### 방법 1: 가우시안 분포 가정

가장 간단한 방법입니다. 일일 수익률이 평균 0, 표준편차가 표본 표준편차인 **가우시안(정규) 분포**를 따른다고 가정합니다. 이 경우, 백테스트가 높은 샤프 비율을 가지면 귀무가설을 매우 쉽게 기각할 수 있습니다. 검정 통계량은 평균을 표준편차로 나누고 데이터 포인트 수의 제곱근을 곱한 것이기 때문입니다(Berntson, 2002):

$$\frac{\text{mean}(\text{ret})}{\text{std}(\text{ret})} \sqrt{n}$$

이 수식의 의미: $\text{mean}/\text{std}$는 일일 **샤프 비율**이고, $\sqrt{n}$은 데이터가 많을수록 통계적 확신이 커지는 효과입니다. 즉 **높은 샤프 비율 + 긴 백테스트 기간 = 높은 통계적 유의성**입니다.

다양한 임계값에 대한 p-값이 표 1.1에 정리되어 있습니다:

| 표 1.1 | $\sqrt{n}$ x 일일 샤프 비율의 임계값 |
|---------|--------------------------------------|
| p-값    | 임계값                               |
| 0.10    | 1.282                                |
| 0.05    | 1.645                                |
| 0.01    | 2.326                                |
| 0.001   | 3.091                                |

*출처:* Berntson (2002).

예를 들어, 일일 샤프 비율에 $\sqrt{n}$을 곱한 값이 2.326 이상이면, 99% 신뢰도로 귀무가설을 기각할 수 있습니다.

### 방법 2: 몬테카를로 시뮬레이션

실제 가격 데이터와 동일한 처음 몇 모멘트(평균, 표준편차 등)와 동일한 길이를 가진 많은 시뮬레이션된 가격 시계열을 생성하고, 이 모든 시뮬레이션에 전략을 실행합니다. 이 가격 시계열의 몇 분의 $p$에서 평균 수익률이 백테스트 수익률 이상인지 확인합니다. 우리의 믿음은 전략의 수익성이 가격 시계열의 미묘한 패턴이나 상관관계를 포착한 것이지, 단지 분포의 처음 몇 모멘트 때문이 아니라는 것입니다.

### 방법 3: 무작위 거래 시뮬레이션

**앤드류 로(Andrew Lo)**와 동료들이 제안한 방법입니다(Lo, Mamaysky, and Wang, 2000). 시뮬레이션된 가격 대신 **시뮬레이션된 거래 세트**를 생성합니다. 롱/숏 진입 거래 수와 평균 보유 기간은 백테스트와 동일하되, 거래들이 실제 과거 가격 시계열에 **무작위로 분포**됩니다. 그런 다음 이 무작위 거래들 중 몇 퍼센트가 백테스트 평균 수익률 이상의 성과를 내는지 측정합니다.

### 예제 1.1: 선물 모멘텀 전략에 대한 가설 검정 — 세 가지 방법 비교

6장에서 설명된 **TU 모멘텀 전략**의 백테스트 결과에 세 가지 가설 검정을 적용합니다. 이 전략은 TU 선물이 양(음)의 12개월 수익률을 가지면 매수(매도)하고, 1개월 보유합니다. 이 전략이 선택된 이유는 단순하고, 고정된 보유 기간을 가져 방법 3 적용이 용이하기 때문입니다(보유 기간을 무작위화할 필요 없이 진입 날짜만 무작위화하면 됩니다).

**방법 1 적용**: 평균 0, 표준편차가 표본 표준편차인 가우시안 분포를 가정합니다. *ret*가 전략의 일일 수익률 배열이면 검정 통계량은 단순히 $\text{mean}(\text{ret})/\text{std}(\text{ret}) \times \sqrt{\text{length}(\text{ret})}$입니다. 우리 데이터에서 이것은 **2.93**으로, 표 1.1과 비교하면 **99% 이상의 확률로 귀무가설을 기각**할 수 있습니다.

**방법 2 적용**: TU 선물의 관찰된 수익률과 동일한 평균, 표준편차, 왜도, 첨도를 가진 무작위 수익률 데이터를 생성합니다. MATLAB의 *pearsrnd* 함수를 사용합니다. 시뮬레이션된 수익률로 가상 가격을 만들고 전략을 실행합니다. 이를 10,000번 반복합니다.

```matlab
moments = {mean(marketRet), std(marketRet), ...
           skewness(marketRet), kurtosis(marketRet)};
numSampleAvgretBetterOrEqualObserved = 0;

for sample = 1:10000
    % 1. 가짜 수익률 생성 (통계적 속성은 같으나 순서는 랜덤)
    marketRet_sim = pearsrnd(moments{:}, length(marketRet), 1);

    % 2. 가짜 가격 차트 생성
    cl_sim = cumprod(1 + marketRet_sim) - 1;

    % 3. 전략 신호 생성 (Lookback 기간 대비 상승/하락 여부)
    longs_sim = cl_sim > backshift(lookback, cl_sim);
    shorts_sim = cl_sim < backshift(lookback, cl_sim);

    % 4. 포지션 보유 기간(holddays) 동안 포지션 유지 로직
    pos_sim = zeros(length(cl_sim), 1);
    for h = 0:holddays-1
        long_sim_lag = backshift(h, longs_sim);
        long_sim_lag(isnan(long_sim_lag)) = false;
        long_sim_lag = logical(long_sim_lag);

        short_sim_lag = backshift(h, shorts_sim);
        short_sim_lag(isnan(short_sim_lag)) = false;
        short_sim_lag = logical(short_sim_lag);

        pos_sim(long_sim_lag) = pos_sim(long_sim_lag) + 1;
        pos_sim(short_sim_lag) = pos_sim(short_sim_lag) - 1;
    end

    % 5. 전략 수익률 계산
    ret_sim = backshift(1, pos_sim) .* marketRet_sim / holddays;
    ret_sim(~isfinite(ret_sim)) = 0;

    % 6. 결과 비교
    if (mean(ret_sim) >= mean(ret))
        numSampleAvgretBetterOrEqualObserved = numSampleAvgretBetterOrEqualObserved + 1;
    end
end
```

(소스 코드는 [www.wiley.com/go/algotrading](http://www.wiley.com/go/algotrading)에서 *TU_mom_hypothesisTest.m*으로 다운로드 가능합니다.)

**결과**: 10,000개 중 **1,166개**가 관찰된 수익률 이상입니다. 귀무가설은 **88% 확률**로만 기각됩니다. 방법 1의 99%에 비해 훨씬 낮습니다! 이는 수익률 분포의 **형태 자체(높은 첨도 등)**가 전략의 성공과 관련이 있음을 시사합니다.

**방법 3 적용**: 롱/숏 거래의 수는 동일하게 유지하되, 진입 **날짜만** 무작위로 섞습니다.

```matlab
numSampleAvgretBetterOrEqualObserved = 0;

for sample = 1:100000
    % 1. 순서 무작위 섞기
    P = randperm(length(longs));

    % 2. 거래 신호의 날짜 순서를 뒤섞음
    longs_sim = longs(P);
    shorts_sim = shorts(P);

    % 3. 포지션 보유 기간(holddays) 동안 포지션 유지 로직
    pos_sim = zeros(length(cl), 1);
    for h = 0:holddays-1
        long_sim_lag = backshift(h, longs_sim);
        long_sim_lag(isnan(long_sim_lag)) = false;
        long_sim_lag = logical(long_sim_lag);

        short_sim_lag = backshift(h, shorts_sim);
        short_sim_lag(isnan(short_sim_lag)) = false;
        short_sim_lag = logical(short_sim_lag);

        pos_sim(long_sim_lag) = pos_sim(long_sim_lag) + 1;
        pos_sim(short_sim_lag) = pos_sim(short_sim_lag) - 1;
    end

    % 4. 가짜 전략 수익률 계산 (원래 시장 수익률 사용, 포지션 타이밍만 다름)
    ret_sim = backshift(1, pos_sim) .* marketRet / holddays;
    ret_sim(isnan(ret_sim)) = 0;

    % 5. 결과 비교
    if (mean(ret_sim) >= mean(ret))
        numSampleAvgretBetterOrEqualObserved = numSampleAvgretBetterOrEqualObserved + 1;
    end
end
```

**결과**: 100,000개 표본 중 관찰된 수익률 이상인 것은 **단 하나도 없습니다.** 세 번째 테스트는 이 전략에 대해 가장 강력한 증거를 제공합니다.

### 왜 세 가지 방법이 다른 답을 줄까?

각 방법이 **다른 귀무가설 확률 분포**를 사용하고, 각 가정된 분포가 전략을 다른 무작위성 벤치마크와 비교하기 때문입니다. 이것이 가설 검정의 한계이기도 합니다. 비평가들이 가설 검정이 결함 있는 방법론이라고 믿는 한 가지 이유입니다(Gill, 1999). 또 다른 이유는 우리가 진정으로 알고 싶은 것은 $P(H_0|R)$ — 결과 $R$을 관찰했을 때 귀무가설이 참일 확률 — 이지만, 실제로 계산하는 것은 $P(R|H_0)$ — 귀무가설이 참일 때 결과 $R$을 얻을 확률 — 이라는 점입니다. $P(R|H_0) = P(H_0|R)$인 경우는 드뭅니다.

그러나 가설 검정이 완벽하지 않더라도, 귀무가설을 **기각하지 못하는** 경우는 매우 흥미로운 통찰을 줍니다. 예제 1.1은 **높은 첨도를 가진 모든 무작위 수익률 분포가 모멘텀 전략에 유리**할 수 있음을 보여줍니다.

---

## 1.4 전략을 백테스트하지 말아야 할 때 — 시간 낭비를 피하는 법

앞서 모든 전략을 백테스트해야 한다고 강조했는데, 왜 일부는 백테스트하지 말라고 할까요? 너무 명백하게 결함이 있어 고려할 가치가 없는 전략들이 있기 때문입니다. 인생은 짧습니다! 백테스팅의 함정에 대해 알게 된 지금, 세부 사항을 모르고도 전략의 가치를 판단할 수 있습니다.

**예제 1:** 백테스트 연간 수익률 30%, 샤프 비율 0.3, 최대 손실 기간 2년인 전략.

매우 적은 트레이더("투자자"와 달리)가 2년간 "물에 잠긴(under water)" 상태를 견딜 수 있습니다. 낮은 샤프 비율과 긴 손실 기간은 전략이 일관적이지 않음을 나타냅니다. 높은 수익률은 우연일 가능성이 높으며, 데이터 스누핑 편향의 결과일 수 있습니다. **교훈**: 높은 수익률이지만 낮은 샤프 비율의 전략을 백테스트하지 마세요. 견딜 수 없는 최대 손실 기간을 가진 전략도 마찬가지입니다.

**예제 2:** 롱 온리 원유 선물 전략이 2007년에 수익률 20%, 샤프 비율 1.5를 기록했습니다.

2007년에 최근월물 원유 선물의 단순 보유 총 수익률은 **47%**, 샤프 비율은 **1.7**이었습니다! 이 전략은 아무것도 안 하는 **매수-보유(buy-and-hold)** 전략보다도 못합니다. **교훈**: 항상 적절한 벤치마크를 선택하세요. 롱 온리 전략의 벤치마크는 매수-보유 수익률이며, 이때 사용해야 할 지표는 샤프 비율이 아닌 **정보 비율(information ratio)**입니다.

**예제 3:** "저가 매수-고가 매도" 전략이 연초에 가장 낮은 가격의 10개 주식을 선택하여 1년간 보유. 2001년 백테스트 수익률 388%.

첫 번째 질문: **생존자 편향이 없는 데이터를 사용했는가?** 오늘까지 살아남은 주식만 포함된 데이터라면, 2001년에 매우 저렴했지만 결국 살아남은 "로또 당첨" 주식만 선택합니다. 상장 폐지 주식이 포함되었다면, 파산 직전 주식을 골라 거의 **100% 손실**을 볼 것입니다. 388%가 아니라 100% 손실이 실제 결과입니다. 저자가 명시하지 않았다면 생존자 편향이 있다고 가정하세요.

**예제 4:** 100개 노드의 **신경망 거래 모델**이 샤프 비율 6을 생성.

"신경망 거래 모델"이라는 용어를 들으면 경보가 울려야 합니다. 100개 노드는 **최소 100개의 매개변수**를 의미합니다. 이 정도면 어떤 시계열에든 맞출 수 있습니다. 데이터 스누핑 편향으로 인해 미래 예측력은 거의 없을 것입니다.

**예제 5:** 고빈도 E-mini S&P 500 선물 전략이 연간 수익률 200%, 샤프 비율 6, 평균 보유 기간 50초.

고빈도 전략을 정말 백테스트할 수 있을까요? 성과가 주문 유형, 실행 방법, **시장 미시 구조(market microstructure)**에 결정적으로 의존합니다. 전체 주문장 과거 데이터가 있어도 다른 참가자의 반응을 예측할 수 없습니다. **"하이젠베르크 불확정성 원리(Heisenberg uncertainty principle)"**가 작동합니다: 주문을 배치하는 행위 자체가 다른 참가자의 행동을 변경합니다. 고빈도 전략의 백테스트에는 **매우 회의적**이어야 합니다.

읽는 모든 전략을 백테스트하기에 인생은 너무 짧으므로, 함정에 대한 인식이 **어떤 전략을 백테스트할지** 선택하는 데 도움이 되기를 바랍니다.

---

## 1.5 백테스트가 미래 수익률을 예측할 수 있을까? — 체제 전환의 위험

모든 함정을 피하고 통계적 유의성이 확보되어도, 백테스트의 예측력은 핵심 가정에 달려 있습니다: **가격 시계열의 통계적 속성이 변하지 않아, 과거에 수익성 있었던 규칙이 미래에도 수익성이 있을 것**이라는 가정입니다. 이 가정은 다양한 정도로 종종 무효화됩니다. 경제 전망이 변하고, 기업 경영진이 바뀌며, 금융 시장의 구조가 변합니다.

지난 10여 년간 미국에서 목격한 주요 **체제 전환(regime shifts)**:

- **2001년 4월 9일, 미국 주식의 십진법화(decimalization)**: 주식 시세가 1/8이나 1/16 페니 단위에서 1센트 단위로 바뀌었습니다. 매수-매도 스프레드가 줄었지만, 최우선 호가에서의 "표시된 유동성(displayed liquidity)"도 감소했습니다(Arnuk and Saluzzi, 2012). 이는 많은 통계적 차익거래 전략의 수익성을 감소시키면서 고빈도 전략의 수익성을 증가시켰습니다.

- **2008년 금융 위기**: 평균 일일 거래량이 **50% 감소**(Durden, 2012). 리테일 거래와 보통주 소유가 특히 줄었습니다. 평균 변동성이 줄었지만, 2010년 5월 **플래시 크래시(flash crash)**와 2011년 8월 미국 부채 신용등급 하향 같은 갑작스러운 폭발의 빈도가 증가했습니다. 높지만 일정한 변동성에서 번영하는 평균 회귀 전략의 수익이 전반적으로 감소했습니다.

- 6장에서 논의되는, **모멘텀 전략의 다년간 약세장**을 시작한 동일한 2008년 금융 위기.

- **SEC의 Regulation NMS** (2007년 7월 시행): 평균 거래 규모의 급격한 감소와 NYSE 블록 거래의 쇠퇴에 기여(Arnuk and Saluzzi, 2012).

- **2007년 6월 공매도 업틱 규칙 제거**와 **2010년 대안적 업틱 규칙 재시행**.

이러한 체제 전환 **이전에** 훌륭했던 전략이 **이후에** 작동하지 않을 수 있으며, 그 반대도 마찬가지입니다. 체제 전환 이전 데이터를 사용한 백테스트는 상당히 무가치할 수 있습니다.

**핵심 메시지**: 알고리즘 거래는 알고리즘, 프로그래밍, 수학에 관한 것**만이** 아닙니다. 시장과 경제의 **근본적인 변화**에 대한 인식도 필요합니다. 마치 자동 조종 장치가 아무리 정교해도, 기상 조건의 급변을 감지하지 못하면 위험한 것처럼요.

---

## 1.6 백테스팅 및 자동 실행 플랫폼 선택 — 나에게 맞는 도구 찾기

소프트웨어 회사들은 모든 수준의 프로그래밍 기술에 맞는 다양한 플랫폼을 제공합니다. 거래 플랫폼 결정 시 두 가지 기본 선택에 직면합니다:

1. **특수 목적 플랫폼** 구매: 해당 플랫폼의 GUI나 전용 언어로 전략 구현
2. **범용 프로그래밍 언어**(C++ 등)로 직접 작성: 독립적으로 하거나, 알고리즘 거래용 라이브러리가 포함된 통합 개발 환경(IDE) 내에서 작업

### 1.6.1 프로그래밍 기술은 얼마나 좋은가? — 수준별 선택 가이드

**프로그래밍을 못하는 경우**: 유일한 선택은 **특수 목적 거래 플랫폼**입니다. 그래픽 "드래그 앤 드롭" 인터페이스로 코딩 없이 전략을 구축합니다. **Deltix**, **Progress Apama**가 대표적입니다. 하지만 구축 가능한 전략이 제한적이며, 장기적으로는 프로그래밍 언어를 배우는 것이 훨씬 효율적입니다. (Deltix와 Progress Apama는 아래 설명된 대로 전략을 지정하는 다른 방법도 제공합니다.)

**초급 — 스크립팅 언어**: 컴파일 없이 즉시 결과를 볼 수 있는 언어들입니다. 많은 트레이더들이 **마이크로소프트 엑셀(Microsoft Excel)**을 사용하지만, 복잡한 전략 구축과 디버깅이 어렵고, 성능도 떨어집니다. 자동 실행에는 브로커의 DDE 링크와 비주얼 베이직(VB) 매크로가 필요하며 상당히 비효율적입니다.

#### 스테로이드를 맞은 엑셀 — FXone 자동 실행 플랫폼

엑셀처럼 보이지만 기본 엔진이 C++로 작성된 **FXone**이라는 통화 거래 플랫폼이 있습니다. 주요 특징:

- **진정한 틱 구동**: 모든 틱(새로운 시세)이 스프레드시트 전체의 재계산을 유발
- **내부 캐시**: 동일 데이터 구독의 중복 없이 캐시에서 검색
- **진정한 멀티스레드**: 두 가지 수준에서 동시 처리. 첫째, 다른 워크북의 다른 전략이 동시에 시장 데이터 수신과 주문 제출 가능. 둘째, 동일 워크북 내 다른 셀도 동시에 업데이트 — 한 셀의 긴 계산이 다른 셀의 주문 제출을 방해하지 않음

![](_page_26_Figure_2.jpeg)

**그림 1.1** FXone 스크린샷.

**독점 프로그래밍 언어 플랫폼**: QuantHouse, RTD Tango, Deltix, Progress Apama 등은 VB만큼 배우기 쉬운 자체 프로그래밍 언어를 제공합니다. 리테일 트레이더에게는 **MetaTrader**, **NinjaTrader**, **Trading Blox**, **TradeStation Easy Language**가 친숙합니다. 사용하기 편하지만, 전략 유형에 일부 제한이 있을 수 있습니다.

**중급 — MATLAB, R, Python**: VB보다 약간 더 많은 기술이 필요하지만, 디버깅의 훨씬 더 큰 용이성, 전략 유형의 훨씬 더 큰 유연성, 대규모 데이터 백테스팅의 더 높은 효율성을 제공합니다. 이들을 **"REPL" 언어**라 합니다 — **Read-Eval-Print-Loop**의 약자로, 수학적 표현을 입력하면 즉시 평가하고 결과를 출력하는 대화형 환경입니다. 고급 계산기처럼 작동하되, 모든 과정을 파일로 저장하고 자동 실행할 수 있습니다. 구문이 C++ 같은 전통적 언어보다 직관적이고, 스칼라/배열/문자열을 유사한 방식으로 처리합니다.

MATLAB은 Java, C++, C# 라이브러리나 API를 활용할 수 있어, 계산 집약적 작업에서 전통적 언어의 효율성을 빌릴 수 있습니다.

많은 트레이더가 MATLAB/R/Python이 백테스팅에 훌륭하다는 것을 알지만, **도구 상자를 추가하면 실행 플랫폼으로도 전환 가능**합니다:

- **MATLAB Datafeed Toolbox**: Trading Technologies의 X_TRADER로 주문 전송
- **IB-Matlab** (undocumentedmatlab.com): Interactive Brokers 연결
- **quant2ib / quant2tt** (exchangeapi.com): Interactive Brokers / Trading Technologies 연결
- **www.pracplay.com**: 월간 요금으로 MATLAB/R에서 15개 이상의 브로커 연결
- **Jev Kuznetsov의 무료 API**: MATLAB Central File Exchange에서 다운로드
- **MAT-FIX** (agoratron.com): FIX 프로토콜로 주문 전송. QuickFIX의 Java나 .NET 함수도 호출 가능(Kozola, 2012)
- **IbPy** (Python용): Interactive Brokers 연결 무료 오픈소스

이런 추가 기능이 브로커 연결을 가능하게 하지만, 연결의 모든 복잡성으로부터 보호해 주지는 않으며, 백테스팅과 실행에 동일한 프로그램을 사용하는 것이 번거로울 수 있습니다.

**상급 — Java, C++, C#**: 가장 유연하고 효율적이며 강건합니다. 모든 브로커가 이 언어들의 API를 제공하거나 FIX 프로토콜을 지원합니다. (QuickFIX는 C++, C#, VB, Python, Ruby에서 사용 가능.) 소프트웨어 산업은 이런 프로그래머를 위해 백테스팅 전용 IDE도 제공합니다. 많은 특수 목적 플랫폼(Deltix, Progress Apama, QuantHouse, RTD Tango 등)도 범용 고급 언어로 전략을 코딩하는 방법을 포함하여 IDE와 유사합니다.

### 1.6.2 백테스팅과 실행이 동일한 프로그램을 사용할 수 있는가? — 편의 이상의 가치

특수 목적 **실행** 플랫폼은 브로커 연결, 실시간 데이터 수신, 주문 전송, 포지션 업데이트의 복잡성을 숨깁니다. 특수 목적 **백테스팅** 플랫폼은 과거 데이터와 통합됩니다. 많은 플랫폼에서 순수한 거래 로직을 함수로 분리하고, 과거 vs. 실시간 데이터 입력을 전환하는 버튼으로 모드를 전환할 수 있습니다.

이 전환 용이성의 세 가지 핵심 장점:

1. **불일치/오류 제거**: 백테스트 전략을 실시간으로 전사하는 과정의 실수를 방지합니다
2. **선행 편향 제거**: 과거 데이터를 실시간처럼 한 번에 하나의 틱이나 봉씩 입력하므로 미래 정보 사용이 불가능합니다
3. **틱 기반 고빈도 전략 백테스팅**: 실행 프로그램이 "이벤트 구동(event-driven)"이므로, 입력 과거 데이터도 틱 기반이면 모든 틱 변화에 의존하는 전략도 백테스트 가능합니다

**표 1.2 백테스팅 및 자동 실행을 위한 오픈소스 통합 개발 환경(IDE) 비교**

| IDE          | 언어                                           | 자산 클래스 | 브로커                                                 | 틱 기반? | CEP 지원? |
|--------------|------------------------------------------------|-------------|--------------------------------------------------------|----------|-----------|
| ActiveQuant  | Java, MATLAB, R                                | 다양        | CTS, FIX, Trading Technologies 지원 브로커             | 예       | 아니오    |
| Algo-Trader  | Java                                           | 다양        | Interactive Brokers, FIX                               | 예       | 예        |
| Marketcetera | Java, Python, Ruby                             | 다양        | 다양, FIX                                              | 예       | 예        |
| OpenQuant    | .NET (C#, VB)                                  | 다양        | 다양, FIX                                              | ?        | 아니오    |
| TradeLink    | .NET (C#, C++, VB), Java, Pascal, Python       | 다양        | 다양, FIX                                              | 예       | 아니오    |

이 표는 오픈소스 IDE의 기능만 비교한 것입니다. 기관급 특수 목적 플랫폼은 일반적으로 이 모든 기능을 갖추고 있습니다. (브로커로서의 FIX는 청산 브로커에 관계없이 FIX 프로토콜을 통해 모든 실행 장소에 직접 접근할 수 있음을 의미합니다.)

### 1.6.3 플랫폼은 어떤 유형의 자산 클래스나 전략을 지원하는가?

최고급 플랫폼을 제외하면, 주식/선물/통화/옵션 **모든 자산 클래스를 지원하는 플랫폼은 거의 없습니다**. MetaTrader는 통화 전용입니다. 다른 자산 클래스 간 차익거래 전략은 특히 어렵습니다. 오픈소스 IDE가 이를 더 잘 처리합니다.

하나의 자산 클래스 내에서도 전략 유형에 제한을 두는 플랫폼이 많습니다. 페어 트레이딩도 특별 모듈이 필요하고, 많은 종목의 통계적 차익거래나 포트폴리오 거래는 처리할 수 없는 경우가 많습니다.

#### 고빈도 거래와 지연 문제

놀랍게도 대부분의 플랫폼이 고빈도 **실행**을 처리할 수 있습니다(1~10ms 지연 허용 시). 극복해야 할 지연의 대부분은:

**1. 실시간 시장 데이터 지연**: 1~10ms 내 시세 수신을 위해서는 거래소나 브로커 데이터 센터에 **코로케이션**하고, 통합 피드 대신 거래소 **직접 피드**를 수신해야 합니다. (Interactive Brokers의 데이터 피드는 250ms마다 스냅샷만 제공합니다.)

**2. 브로커 주문 확인 지연**: 지정가 주문의 적시 상태 확인이 중요합니다. 일부 리테일 브로커는 최대 **6초** 지연으로 고빈도 거래가 사실상 불가능합니다.

#### 거래 프로그램의 코로케이션 — 속도를 위한 물리적 이동

**코로케이션(colocation)**은 거래 프로그램을 물리적으로 거래소나 브로커 가까이 배치하는 것입니다. 여러 수준이 있습니다:

- **클라우드/VPS**: Amazon EC2, slicehost.com, gogrid.com 등. 전력/인터넷 중단 방지가 주 이점이며, 반드시 속도 향상은 아닙니다. 직접 핑 테스트로 확인해야 합니다 (데스크톱에서 IB 핑: ~55ms, EC2에서: ~25ms, IB 근처 VPS에서: ~16~34ms).
- **전용 서버**: Equinix, Telx 같은 금융 전문 호스팅 회사가 거래소 인근 데이터 센터 운영
- **엑스트라넷**: BT Radianz, Savvis, TNS가 최소 통신 속도를 보장하는 사설 네트워크 제공. 전용 회선도 가능
- **브로커 데이터 센터**: Lime Brokerage, FXCM 등이 코로케이션 서비스 제공. 내부 네트워크로 데이터 전송
- **거래소/ECN 직접**: 궁극의 선택이나 비용이 높고, 프라임 브로커 관계와 **스폰서드 액세스(sponsored access)**가 필요(Johnson, 2010). 외환 ECN(Currenex, EBS, FXall, Hotspot)은 Equinix NY4 같은 대형 데이터 센터에 위치하여 비용이 더 낮음

**지적 재산 보호**: 원격 서버에 소스 코드가 아닌 **실행 파일(executables)**만 저장하세요. MATLAB .m 파일은 .p 파일로 변환 가능합니다. 시간 기반 비밀번호도 추가할 수 있습니다.

사실상 모든 소프트웨어(엑셀 VB 매크로 제외)는 새 데이터 수신 후 **10ms 미만**에 주문을 제출하므로 소프트웨어/하드웨어 지연은 보통 병목이 아닙니다. 그러나 고빈도 **백테스팅**은 다른 문제입니다. 수개월분의 틱 데이터(때로는 레벨 2 시세)를 입력해야 하며, 데이터 양이 메모리를 압도할 수 있습니다. 대부분의 플랫폼은 이 정도 데이터 처리에 적합하지 않으며, 보통 맞춤형 독립 프로그램이 필요합니다.

#### 멀티스레딩과 여러 종목의 고빈도 거래

**멀티스레딩(multithreading)**은 여러 이벤트에 동시 응답하는 능력입니다. BBRY 매도를 결정하는 동안 AAPL 매수가 지연되면 안 되니까요! Java나 Python에서는 기본 내장이지만, MATLAB은 별도 **병렬 컴퓨팅 도구 상자(Parallel Computing Toolbox)**가 필요하고 12개 스레드로 제한됩니다 (500개 주식 동시 거래에는 부족).

MATLAB의 멀티스레딩 부재를 "틱 손실"과 혼동하지 마세요. 리스너 A가 처리 중이어도 리스너 B는 틱을 놓치지 않습니다. A가 끝나면 B가 밀린 틱을 처리합니다(Kuznetsov, 2010).

고빈도 거래 외에도, **뉴스 구동 거래**는 기계 판독 가능한 뉴스 피드를 요구하며 대부분의 플랫폼이 지원하지 않습니다. 예외로 Progress Apama는 Dow Jones/Reuters 뉴스 피드를, Deltix는 Ravenpack 뉴스 감성 데이터를, Marketcetera는 benzinga.com 뉴스 피드를 통합합니다. 독립 프로그램이라면 뉴스 제공자의 API를 사용하거나 XML 파일을 읽을 수 있습니다. 7장에서 이벤트 구동 거래를 더 논의합니다.

### 1.6.4 플랫폼에 복합 이벤트 처리가 있는가? — 이벤트에 즉각 대응하기

**복합 이벤트 처리(Complex Event Processing, CEP)**는 프로그램이 이벤트(새 틱, 뉴스 등)에 즉각 응답하는 것입니다. 핵심은 프로그램이 **이벤트 구동**이지 봉 구동이 아니라는 점 — 봉의 끝에서 폴링하지 않고, 이벤트와 응답 사이에 지연이 없습니다.

즉시성만 필요하다면 브로커 API의 **콜백 함수(callback functions)**로 충분합니다. 하지만 규칙이 "지난 30분 주문 흐름이 양수이고, 가격이 이동평균 위이고, 변동성이 낮고, 중요 뉴스가 도착했을 때 매도"처럼 복잡하다면? during, between, afterwards, in parallel 같은 절을 포함하는 규칙이라면? CEP 언어가 더 간결하게 표현할 수 있습니다.

데이터 스누핑 편향을 피하기 위해 규칙이 단순해야 한다는 주장에 대해, CEP 지지자들은 데이터 마이닝이 아니라 **경험 있는 트레이더들이 이미 아는 규칙을 구현**하는 것이라고 답합니다. **Progress Apama**가 CEP 기술로 유명하며, 표 1.2에서 보듯 일부 오픈소스 IDE(Algo-Trader, Marketcetera)에도 CEP가 있습니다.

---

## 핵심 포인트 정리 — 대화로 풀어보기

### 함정 제거 체크리스트

- 백테스팅과 실시간 실행에 **동일한 프로그램**을 사용하는 플랫폼은 선행 편향을 제거합니다.
- 표본 외 테스트, 교차 검증, 높은 샤프 비율이 모두 좋은 관행이지만, **워크포워드 테스트**보다 결정적인 것은 없습니다.
- **단순한 모델**은 데이터 스누핑 편향에 대한 단순한 치료법입니다.
- "모델이 2012/7/9에 THQI에 대해 '숏' 신호를 생성했다면? 아, **1:10 역분할**에 대해 가격을 조정하는 것을 잊었기 때문입니다!"
- "모델이 CMC 주식을 방금 매수했나요? 오늘이 **배당 기준일**인데 과거 가격을 조정했나요?"
- "모델이 **롱 온리**라면, 데이터에 **생존자 편향**이 없는지 확인하세요."
- "종가를 사용한 평균 회귀 주식 모델의 백테스트가 좋아 보여도, **1차 거래소 데이터**로 다시 테스트하면 성과 감소를 예상하세요."
- "2008년 11월에 금융주를 공매도했나요? **공매도 금지**를 잊지 마세요."
- "고빈도 숏 거래에 **업틱 규칙**을 적용했나요?"
- "캘린더 스프레드 모델이 가격 차이를 사용하는데, 왜 **수익률 역조정**을 쓰고 있나요?"
- "평균 회귀 일중 선물 스프레드가 실시간에서 저조하다면? **봉 기반 대신 틱 기반 데이터**를 써야 했을 수 있습니다."
- "2008년 이전에 잘 작동했다고 **이후에도** 잘 된다는 뜻이 아닙니다."

### 통계적 유의성 해석

- "APR 10%가 1% 이내로 유의하다" = "10,000개의 시뮬레이션 가격 시계열에 전략을 돌리면, APR 10% 이상인 표본이 100개뿐이다."
- 대안: "거래 진입 날짜를 무작위화하면, APR 10% 이상인 순열이 100개 중 1개뿐이다."

### 플랫폼 선택 가이드

- "5천만 달러 펀드를 시작하는 뛰어난 수학자인데 프로그래밍을 모릅니다." -> Deltix, QuantHouse, Progress Apama, RTD Tango 같은 **기관용 특수 목적 플랫폼**
- "경험 많은 재량적 독립 트레이더이며 전략을 자동화하고 싶습니다." -> MetaTrader, NinjaTrader, Trading Blox, TradeStation 같은 **리테일 플랫폼**
- "MATLAB을 사용한 전략 연구에 뛰어난 퀀트입니다." -> quant2ib, quant2tt, www.pracplay.com, MATFIX 등의 **브릿지**
- "훌륭한 C++/C#/Java 프로그래머이지만 브로커 연결이 싫습니다." -> Marketcetera, TradeLink, AlgoTrader, ActiveQuant 같은 **오픈소스 IDE**

### 자동 실행 관련

- "EC2에 코로케이션하면 더 빠를까?" -> 반드시 그렇지 않습니다. 직접 **핑 테스트**로 확인하세요.
- "MATLAB 병렬 도구 상자로 SPX 500개 주식 동시 거래?" -> **12개 스레드로 제한**됩니다. Java/Python으로 직접 작성하면 진정한 멀티스레딩이 가능합니다.
- "CEP 없이는 틱 기반 거래 불가?" -> 아닙니다. CEP가 없어도 **콜백 함수**로 틱 기반 거래가 가능한 경우가 많습니다.

---

## 핵심 용어 해설

| 용어 | 쉬운 설명 |
|------|----------|
| **백테스팅(backtesting)** | 과거 데이터로 전략을 시뮬레이션하여 성과를 확인하는 과정. 모의 시험과 같음 |
| **자동 실행(automated execution)** | 컴퓨터가 거래 주문을 자동으로 내는 것. 비행기의 자동 조종 장치와 같음 |
| **선행 편향(look-ahead bias)** | 백테스트에서 미래 정보를 실수로 사용하는 프로그래밍 오류 |
| **데이터 스누핑 편향(data-snooping bias)** | 과거 데이터의 우연한 패턴에 모델을 과도하게 맞추어 미래 예측력이 사라지는 것 |
| **생존자 편향(survivorship bias)** | 상장 폐지된 주식을 제외한 데이터로 인해 백테스트 성과가 부풀려지는 현상 |
| **샤프 비율(Sharpe ratio)** | 수익률을 위험(변동성)으로 나눈 값. 위험 대비 보상을 측정 |
| **표본 외 테스트(out-of-sample test)** | 모델 훈련에 사용하지 않은 데이터로 성과를 검증하는 것 |
| **교차 검증(cross-validation)** | 데이터의 여러 부분 집합으로 번갈아 훈련/테스트하여 모델의 일관성 확인 |
| **워크포워드 테스트(walk-forward test)** | 실시간 또는 모의 거래로 전략을 검증하는 궁극의 표본 외 테스트 |
| **체제 전환(regime shift)** | 시장의 구조적 특성이 근본적으로 바뀌어 기존 전략이 무효화되는 현상 |
| **p-값(p-value)** | 귀무가설이 참일 때 관찰된 결과가 나올 확률. 작을수록 결과가 유의미 |
| **가설 검정(hypothesis testing)** | 관찰된 결과가 우연인지 진짜 효과인지 통계적으로 판별하는 방법 |
| **몬테카를로 시뮬레이션(Monte Carlo simulation)** | 수천 번의 무작위 시나리오를 생성하여 통계적 속성을 추정하는 방법 |
| **연속 계약(continuous contract)** | 만기가 다른 선물 계약들을 이어 붙인 하나의 연속적 가격 시계열 |
| **코로케이션(colocation)** | 거래 프로그램을 거래소/브로커 근처 데이터 센터에 물리적으로 배치하여 지연을 줄이는 것 |
| **복합 이벤트 처리(CEP)** | 틱이나 뉴스 같은 이벤트에 즉각 응답하여 거래 행동을 취하는 기술 |
| **평균 회귀(mean reversion)** | 가격이 장기 평균으로 되돌아오는 경향 |
| **모멘텀(momentum)** | 가격이 기존 추세를 유지하는 경향 |
| **오컴의 면도날(Occam's razor)** | "불필요한 복잡성을 추가하지 마라" — 단순한 모델이 선호되는 원칙 |
| **정보 비율(information ratio)** | 벤치마크 대비 초과 수익을 추적 오차로 나눈 값. 롱 온리 전략 평가에 적합 |
